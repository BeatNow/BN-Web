{
  "version": 3,
  "sources": ["../src/consts.ts", "../src/utils.ts", "../src/analyzer.ts", "../src/realtime-bpm-analyzer.ts", "../processor/realtime-bpm-processor.ts"],
  "sourcesContent": ["export const realtimeBpmProcessorName = 'realtime-bpm-processor';\nexport const startThreshold = 0.95;\nexport const minValidThreshold = 0.2;\nexport const minPeaks = 15;\nexport const thresholdStep = 0.05;\nexport const frequencyValue = 200;\nexport const qualityValue = 1;\n\n", "import * as consts from './consts';\nimport type {Peaks, ValidPeaks, NextIndexPeaks, OnThresholdFunction, AggregateData} from './types';\n\n/**\n * Loop between .9 and minValidThreshold at .2 by default, passing the threshold to the function\n * @param onThreshold Function for each iteration, you must return a boolean, true will exit the loop process\n * @param minValidThreshold minValidThreshold usualy 0.2\n * @param startThreshold startThreshold usualy 0.9\n * @param thresholdStep thresholdStep usuably 0.05\n * @returns A promise that resolves nothing\n */\nexport async function descendingOverThresholds(onThreshold: OnThresholdFunction, minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): Promise<void> {\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    const shouldExit = await onThreshold(threshold);\n    if (shouldExit) {\n      break;\n    }\n  } while (threshold > minValidThreshold);\n}\n\n/**\n * Generate an object with keys as thresholds and will containes validPeaks\n * @param minValidThreshold minValidThreshold usualy 0.2\n * @param startThreshold startThreshold usualy 0.9\n * @param thresholdStep thresholdStep usuably 0.05\n * @returns Collection of validPeaks by thresholds\n */\nexport function generateValidPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): ValidPeaks {\n  const object: Record<string, Peaks> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = [];\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\n/**\n * Generate an object with keys as thresholds and will containes NextIndexPeaks\n * @param minValidThreshold Minimum threshold to reach (we're descending from the startThreshold)\n * @param startThreshold Starting threshold\n * @param thresholdStep Usually 0.05\n * @returns Collection of NextIndexPeaks by thresholds\n */\nexport function generateNextIndexPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): NextIndexPeaks {\n  const object: Record<string, number> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = 0;\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\n/**\n * Creates a function that aggregates incoming PCM data into chunks.\n * @returns A function that accepts PCM data and aggregates it into chunks.\n */\nexport function chunckAggregator(): (pcmData: Float32Array) => AggregateData {\n  const bufferSize = 4096;\n\n  /**\n   * Track the current buffer fill level.\n   */\n  let _bytesWritten = 0;\n\n  /**\n   * Create a buffer of fixed size.\n   */\n  let buffer: Float32Array = new Float32Array(0);\n\n  /**\n   * Initialize the buffer.\n   */\n  function initBuffer(): void {\n    _bytesWritten = 0;\n    buffer = new Float32Array(0);\n  }\n\n  /**\n   * Checks if the buffer is full.\n   * @returns True if the buffer is full, otherwise false.\n   */\n  function isBufferFull(): boolean {\n    return _bytesWritten === bufferSize;\n  }\n\n  /**\n   * Flushes the buffer.\n   */\n  function flush(): void {\n    initBuffer();\n  }\n\n  /**\n   * Aggregates incoming PCM data into chunks.\n   * @param pcmData - The PCM data to be aggregated.\n   * @returns Object containing aggregated data and buffer information.\n   */\n  return function (pcmData: Float32Array): AggregateData {\n    if (isBufferFull()) {\n      flush();\n    }\n\n    const newBuffer = new Float32Array(buffer.length + pcmData.length);\n    newBuffer.set(buffer, 0);\n    newBuffer.set(pcmData, buffer.length);\n    buffer = newBuffer;\n    _bytesWritten += pcmData.length;\n\n    return {\n      isBufferFull: isBufferFull(),\n      buffer,\n      bufferSize,\n    };\n  };\n}\n\n/**\n * Computes the number of indexes we need to skip based on sampleRate\n * @param durationSeconds Duration expressed in seconds\n * @param sampleRate Sample rate, typically 48000, 441000, etc\n * @returns The number of indexes we need to skip\n */\nexport function computeIndexesToSkip(durationSeconds: number, sampleRate: number): number {\n  return Math.round(durationSeconds * sampleRate);\n}\n", "import {descendingOverThresholds} from './utils';\nimport type {\n  Peaks,\n  PeaksAndThreshold,\n  BpmCandidates,\n  Interval,\n  Tempo,\n  Threshold,\n  AnalyzerFindPeaksOptions,\n  AnalyzerGroupByTempoOptions,\n  AnalyzerComputeBpmOptions,\n  BiquadFilterOptions,\n  AnalyzerFindPeaksAtTheshold,\n} from './types';\nimport * as consts from './consts';\nimport * as utils from './utils';\n\n/**\n * Find peaks when the signal if greater than the threshold, then move 10_000 indexes (represents ~0.23s) to ignore the descending phase of the parabol\n * @param options - AnalyzerFindPeaksAtTheshold\n * @param options.audioSampleRate - Sample rate\n * @param options.data - Buffer channel data\n * @param options.threshold - Threshold for qualifying as a peak\n * @param options.offset - Position where we start to loop\n * @returns Peaks found that are greater than the threshold\n */\nexport function findPeaksAtThreshold({\n  audioSampleRate,\n  data,\n  threshold,\n  offset = 0,\n}: AnalyzerFindPeaksAtTheshold): PeaksAndThreshold {\n  const peaks: Peaks = [];\n  const skipForwardIndexes = utils.computeIndexesToSkip(0.25, audioSampleRate);\n\n  const {length} = data;\n\n  /**\n   * Identify peaks that are greater than the threshold, adding them to the collection\n   */\n  for (let i = offset; i < length; i += 1) {\n    if (data[i] > threshold) {\n      peaks.push(i);\n\n      /**\n       * Skip forward ~0.25s to pass this peak\n       */\n      i += skipForwardIndexes;\n    }\n  }\n\n  return {\n    peaks,\n    threshold,\n  };\n}\n\n/**\n * Find the minimum amount of peaks from top to bottom threshold, it's necessary to analyze at least 10seconds at 90bpm\n * @param options - AnalyzerFindPeaksOptions\n * @param options.audioSampleRate - Sample rate\n * @param options.channelData - Channel data\n * @returns Suffisent amount of peaks in order to continue further the process\n */\nexport async function findPeaks({\n  audioSampleRate,\n  channelData,\n}: AnalyzerFindPeaksOptions): Promise<PeaksAndThreshold> {\n  let validPeaks: Peaks = [];\n  let validThreshold = 0;\n\n  await descendingOverThresholds(async threshold => {\n    const {peaks} = findPeaksAtThreshold({audioSampleRate, data: channelData, threshold});\n\n    /**\n     * Loop over peaks\n     */\n    if (peaks.length < consts.minPeaks) {\n      return false;\n    }\n\n    validPeaks = peaks;\n    validThreshold = threshold;\n\n    return true;\n  });\n\n  return {\n    peaks: validPeaks,\n    threshold: validThreshold,\n  };\n}\n\n/**\n * Helpfull function to create standard and shared lowpass and highpass filters\n * Important Note: The original library wasn't using properly the lowpass filter and it was not applied at all.\n * This method should not be used unitl more research and documented tests will be acheived.\n * @param context - AudioContext instance\n * @param options - Optionnal BiquadFilterOptions\n * @returns BiquadFilterNode\n */\nexport function getBiquadFilter(context: OfflineAudioContext | AudioContext, options?: BiquadFilterOptions): BiquadFilterNode {\n  const lowpass = context.createBiquadFilter();\n\n  lowpass.type = 'lowpass';\n  lowpass.frequency.value = options?.frequencyValue ?? consts.frequencyValue;\n  lowpass.Q.value = options?.qualityValue ?? consts.qualityValue;\n\n  return lowpass;\n}\n\n/**\n * Apply to the source a biquad lowpass filter\n * @param buffer - Audio buffer\n * @param options - Optionnal BiquadFilterOptions\n * @returns A Promise that resolves an AudioBuffer instance\n */\nexport async function getOfflineLowPassSource(buffer: AudioBuffer, options?: BiquadFilterOptions): Promise<AudioBuffer> {\n  const {length, numberOfChannels, sampleRate} = buffer;\n  const offlineAudioContext = new OfflineAudioContext(numberOfChannels, length, sampleRate);\n\n  /**\n   * Create buffer source\n   */\n  const source = offlineAudioContext.createBufferSource();\n  source.buffer = buffer;\n\n  const lowpass = getBiquadFilter(offlineAudioContext, options);\n\n  /**\n   * Pipe the song into the filter, and the filter into the offline context\n   */\n  source.connect(lowpass);\n  lowpass.connect(offlineAudioContext.destination);\n\n  source.start(0);\n\n  const audioBuffer = await offlineAudioContext.startRendering();\n\n  return audioBuffer;\n}\n\n/**\n * Return the computed bpm from data\n * @param options - AnalyzerComputeBpmOptions\n * @param options.data - Contain valid peaks\n * @param options.audioSampleRate - Audio sample rate\n * @returns A Promise that resolves BPM Candidates\n */\nexport async function computeBpm({\n  audioSampleRate,\n  data,\n}: AnalyzerComputeBpmOptions): Promise<BpmCandidates> {\n  const minPeaks = consts.minPeaks;\n\n  /**\n   * Flag to fix Object.keys looping\n   */\n  let hasPeaks = false;\n  let foundThreshold = consts.minValidThreshold;\n\n  await descendingOverThresholds(async (threshold: Threshold) => {\n    if (hasPeaks) {\n      return true;\n    }\n\n    if (data[threshold].length > minPeaks) {\n      hasPeaks = true;\n      foundThreshold = threshold;\n    }\n\n    return false;\n  });\n\n  if (hasPeaks && foundThreshold) {\n    const intervals = identifyIntervals(data[foundThreshold]);\n    const tempos = groupByTempo({audioSampleRate, intervalCounts: intervals});\n    const candidates = getTopCandidates(tempos);\n\n    const bpmCandidates: BpmCandidates = {\n      bpm: candidates,\n      threshold: foundThreshold,\n    };\n\n    return bpmCandidates;\n  }\n\n  return {\n    bpm: [],\n    threshold: foundThreshold,\n  };\n}\n\n/**\n * Sort results by count and return top candidate\n * @param candidates - BPMs with count\n * @param length - Amount of returned candidates (default: 5)\n * @returns Returns the 5 top candidates with highest counts\n */\nexport function getTopCandidates(candidates: Tempo[], length = 5): Tempo[] {\n  return candidates.sort((a, b) => (b.count - a.count)).splice(0, length);\n}\n\n/**\n * Gets the top candidate from the array\n * @param candidates - BPMs with counts.\n * @returns Returns the top candidate with the highest count.\n */\nexport function getTopCandidate(candidates: Tempo[]): number {\n  if (candidates.length === 0) {\n    throw new Error('Could not find enough samples for a reliable detection.');\n  }\n\n  const [first] = candidates.sort((a, b) => (b.count - a.count));\n\n  return first.tempo;\n}\n\n/**\n * Identify intervals between bass peaks\n * @param peaks - Array of qualified bass peaks\n * @returns Return a collection of intervals between peaks\n */\nexport function identifyIntervals(peaks: Peaks): Interval[] {\n  const intervals: Interval[] = [];\n\n  for (let n = 0; n < peaks.length; n++) {\n    for (let i = 0; i < 10; i++) {\n      const peak = peaks[n];\n      const peakIndex = n + i;\n      const interval = peaks[peakIndex] - peak;\n\n      /**\n       * Try and find a matching interval and increase it's count\n       */\n      const foundInterval = intervals.some((intervalCount: Interval) => {\n        if (intervalCount.interval === interval) {\n          intervalCount.count += 1;\n          return intervalCount.count;\n        }\n\n        return false;\n      });\n\n      /**\n       * Add the interval to the collection if it's unique\n       */\n      if (!foundInterval) {\n        const item: Interval = {\n          interval,\n          count: 1,\n        };\n        intervals.push(item);\n      }\n    }\n  }\n\n  return intervals;\n}\n\n/**\n * Figure out best possible tempo candidates\n * @param options - AnalyzerGroupByTempoOptions\n * @param options.audioSampleRate - Audio sample rate\n * @param options.intervalCounts - List of identified intervals\n * @returns Intervals grouped with similar values\n */\nexport function groupByTempo({\n  audioSampleRate,\n  intervalCounts,\n}: AnalyzerGroupByTempoOptions): Tempo[] {\n  const tempoCounts: Tempo[] = [];\n\n  for (const intervalCount of intervalCounts) {\n    /**\n     * Skip if interval is equal 0\n     */\n    if (intervalCount.interval === 0) {\n      continue;\n    }\n\n    intervalCount.interval = Math.abs(intervalCount.interval);\n\n    /**\n     * Convert an interval to tempo\n     */\n    let theoreticalTempo = (60 / (intervalCount.interval / audioSampleRate));\n\n    /**\n     * Adjust the tempo to fit within the 90-180 BPM range\n     */\n    while (theoreticalTempo < 90) {\n      theoreticalTempo *= 2;\n    }\n\n    while (theoreticalTempo > 180) {\n      theoreticalTempo /= 2;\n    }\n\n    /**\n     * Round to legible integer\n     */\n    theoreticalTempo = Math.round(theoreticalTempo);\n\n    /**\n     * See if another interval resolved to the same tempo\n     */\n    const foundTempo: boolean = tempoCounts.some((tempoCount: Tempo) => {\n      if (tempoCount.tempo === theoreticalTempo) {\n        tempoCount.count += intervalCount.count;\n        return tempoCount.count;\n      }\n\n      return false;\n    });\n\n    /**\n     * Add a unique tempo to the collection\n     */\n    if (!foundTempo) {\n      const tempo: Tempo = {\n        tempo: theoreticalTempo,\n        count: intervalCount.count,\n        confidence: 0,\n      };\n\n      tempoCounts.push(tempo);\n    }\n  }\n\n  return tempoCounts;\n}\n\n/**\n * Fastest way to detect the BPM from an AudioBuffer\n * @param originalBuffer - AudioBuffer\n * @param options - BiquadFilterOptions\n * @returns Returns the best candidates\n */\nexport async function analyzeFullBuffer(originalBuffer: AudioBuffer, options?: BiquadFilterOptions): Promise<Tempo[]> {\n  const buffer = await getOfflineLowPassSource(originalBuffer, options);\n  const channelData = buffer.getChannelData(0);\n  const {peaks} = await findPeaks({audioSampleRate: buffer.sampleRate, channelData});\n  const intervals = identifyIntervals(peaks);\n  const tempos = groupByTempo({audioSampleRate: buffer.sampleRate, intervalCounts: intervals});\n  const topCandidates = getTopCandidates(tempos);\n\n  return topCandidates;\n}\n", "import {findPeaksAtThreshold, computeBpm} from './analyzer';\nimport type {\n  RealTimeBpmAnalyzerOptions,\n  RealTimeBpmAnalyzerParameters,\n  ValidPeaks,\n  NextIndexPeaks,\n  BpmCandidates,\n  Threshold,\n  RealtimeFindPeaksOptions,\n  RealtimeAnalyzeChunkOptions,\n} from './types';\nimport {\n  generateValidPeaksModel,\n  generateNextIndexPeaksModel,\n  descendingOverThresholds,\n} from './utils';\nimport * as consts from './consts';\n\n/**\n * Initial value of key parameters of the analyzer\n */\nconst initialValue = {\n  minValidThreshold: () => consts.minValidThreshold,\n  validPeaks: () => generateValidPeaksModel(),\n  nextIndexPeaks: () => generateNextIndexPeaksModel(),\n  skipIndexes: () => 1,\n  effectiveBufferTime: () => 0,\n};\n\nexport class RealTimeBpmAnalyzer {\n  /**\n   * Default configuration\n   */\n  options: RealTimeBpmAnalyzerOptions = {\n    continuousAnalysis: false,\n    stabilizationTime: 20000,\n    muteTimeInIndexes: 10000,\n    debug: false,\n  };\n\n  /**\n   * Minimum valid threshold, below this level result would be irrelevant.\n   */\n  minValidThreshold: Threshold = initialValue.minValidThreshold();\n  /**\n   * Contain all valid peaks\n   */\n  validPeaks: ValidPeaks = initialValue.validPeaks();\n  /**\n   * Next index (+10000 ...) to take care about peaks\n   */\n  nextIndexPeaks: NextIndexPeaks = initialValue.nextIndexPeaks();\n  /**\n   * Number / Position of chunks\n   */\n  skipIndexes: number = initialValue.skipIndexes();\n  effectiveBufferTime: number = initialValue.effectiveBufferTime();\n  /**\n   * Computed values\n   */\n  computedStabilizationTimeInSeconds = 0;\n\n  constructor(options: RealTimeBpmAnalyzerParameters = {}) {\n    Object.assign(this.options, options);\n    this.updateComputedValues();\n  }\n\n  /**\n   * Update the computed values\n   */\n  updateComputedValues() {\n    this.computedStabilizationTimeInSeconds = this.options.stabilizationTime / 1000;\n  }\n\n  /**\n   * Reset BPM computation properties to get a fresh start\n   */\n  reset(): void {\n    this.minValidThreshold = initialValue.minValidThreshold();\n    this.validPeaks = initialValue.validPeaks();\n    this.nextIndexPeaks = initialValue.nextIndexPeaks();\n    this.skipIndexes = initialValue.skipIndexes();\n    this.effectiveBufferTime = initialValue.effectiveBufferTime();\n  }\n\n  /**\n   * Remve all validPeaks between the minThreshold pass in param to optimize the weight of datas\n   * @param minThreshold - Value between 0.9 and 0.2\n   */\n  async clearValidPeaks(minThreshold: Threshold): Promise<void> {\n    this.minValidThreshold = Number.parseFloat(minThreshold.toFixed(2));\n\n    await descendingOverThresholds(async threshold => {\n      if (threshold < minThreshold && this.validPeaks[threshold] !== undefined) {\n        delete this.validPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n        delete this.nextIndexPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * Attach this function to an audioprocess event on a audio/video node to compute BPM / Tempo in realtime\n   * @param options - RealtimeAnalyzeChunkOptions\n   * @param options.audioSampleRate - Audio sample rate (44100)\n   * @param options.channelData - Channel data\n   * @param options.bufferSize - Buffer size (4096)\n   * @param options.postMessage - Function to post a message to the processor node\n   */\n  async analyzeChunck({audioSampleRate, channelData, bufferSize, postMessage}: RealtimeAnalyzeChunkOptions): Promise<void> {\n    if (this.options.debug) {\n      postMessage({message: 'ANALYZE_CHUNK', data: channelData});\n    }\n\n    /**\n     * We are summing up the size of each analyzed chunks in order to compute later if we reached the stabilizationTime\n     * Ex: effectiveBufferTime / audioSampleRate = timeInSeconds (1000000/44100=22s)\n     */\n    this.effectiveBufferTime += bufferSize;\n\n    /**\n     * Compute the maximum index with all previous chunks\n     */\n    const currentMaxIndex = bufferSize * this.skipIndexes;\n\n    /**\n     * Compute the minimum index with all previous chunks\n     */\n    const currentMinIndex = currentMaxIndex - bufferSize;\n\n    /**\n     * Mutate nextIndexPeaks and validPeaks if possible\n     */\n    await this.findPeaks({\n      audioSampleRate,\n      channelData,\n      bufferSize,\n      currentMinIndex,\n      currentMaxIndex,\n      postMessage,\n    });\n\n    /**\n     * Increment chunk\n     */\n    this.skipIndexes++;\n\n    const data: BpmCandidates = await computeBpm({audioSampleRate, data: this.validPeaks});\n    const {threshold} = data;\n    postMessage({message: 'BPM', data});\n\n    /**\n     * If the results found have a \"high\" threshold, the BPM is considered stable/strong\n     */\n    if (this.minValidThreshold < threshold) {\n      postMessage({message: 'BPM_STABLE', data});\n      await this.clearValidPeaks(threshold);\n    }\n\n    /**\n     * After x time, we reinit the analyzer\n     */\n    if (this.options.continuousAnalysis && this.effectiveBufferTime / audioSampleRate > this.computedStabilizationTimeInSeconds) {\n      this.reset();\n      postMessage({message: 'ANALYZER_RESETED'});\n    }\n  }\n\n  /**\n   * Find the best threshold with enought peaks\n   * @param options - Options for finding peaks\n   * @param options.audioSampleRate - Sample rate\n   * @param options.channelData - Channel data\n   * @param options.bufferSize - Buffer size\n   * @param options.currentMinIndex - Current minimum index\n   * @param options.currentMaxIndex - Current maximum index\n   * @param options.postMessage - Function to post a message to the processor node\n   */\n  async findPeaks({\n    audioSampleRate,\n    channelData,\n    bufferSize,\n    currentMinIndex,\n    currentMaxIndex,\n    postMessage,\n  }: RealtimeFindPeaksOptions): Promise<void> {\n    await descendingOverThresholds(async threshold => {\n      if (this.nextIndexPeaks[threshold] >= currentMaxIndex) {\n        return false;\n      }\n\n      /**\n       * Get the next index in the next chunk\n       */\n      const offsetForNextPeak = this.nextIndexPeaks[threshold] % bufferSize; // 0 - 4095\n\n      const {peaks, threshold: atThreshold} = findPeaksAtThreshold({audioSampleRate, data: channelData, threshold, offset: offsetForNextPeak});\n\n      /**\n       * Loop over peaks\n       */\n      if (peaks.length === 0) {\n        return false;\n      }\n\n      for (const relativeChunkPeak of peaks) {\n        const index = currentMinIndex + relativeChunkPeak;\n\n        /**\n         * Add current Index + muteTimeInIndexes (10000/44100=0.22s)\n         */\n        this.nextIndexPeaks[atThreshold] = index + this.options.muteTimeInIndexes;\n\n        /**\n         * Store valid relativeChunkPeak Indexes\n         */\n        this.validPeaks[atThreshold].push(index);\n\n        if (this.options.debug) {\n          postMessage({\n            message: 'VALID_PEAK',\n            data: {\n              threshold: atThreshold,\n              index,\n            },\n          });\n        }\n      }\n\n      return false;\n    }, this.minValidThreshold);\n  }\n}\n", "import {realtimeBpmProcessorName} from '../src/consts';\nimport {chunckAggregator} from '../src/utils';\nimport {RealTimeBpmAnalyzer} from '../src/realtime-bpm-analyzer';\nimport type {RealtimeBpmAnalyzerEvents, AggregateData, RealTimeBpmAnalyzerParameters, PostMessageEvents} from '../src/types';\n\n/**\n * Those declaration are from the package @types/audioworklet. But it is not compatible with the lib 'dom'.\n */\n/* eslint-disable no-var, @typescript-eslint/prefer-function-type, @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions, @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention */\ndeclare var sampleRate: number;\n\ninterface AudioWorkletProcessor {\n  readonly port: AuthorizedMessagePort;\n}\n\n// Define a type for a message port that only accepts specific message types\ninterface AuthorizedMessagePort extends MessagePort {\n  postMessage(message: PostMessageEvents): void;\n}\n\ntype AudioWorkletProcessorParameters = {\n  numberOfInputs: number;\n  numberOfOutputs: number;\n  processorOptions: RealTimeBpmAnalyzerParameters;\n};\n\ndeclare var AudioWorkletProcessor: {\n  prototype: AudioWorkletProcessor;\n  new(options?: AudioWorkletProcessorParameters): AudioWorkletProcessor;\n};\n\ninterface AudioWorkletProcessorImpl extends AudioWorkletProcessor {\n  process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean;\n}\n\ninterface WorkletGlobalScope {}\n\ndeclare var WorkletGlobalScope: {\n  prototype: WorkletGlobalScope;\n  new(): WorkletGlobalScope;\n};\n\ninterface AudioWorkletGlobalScope extends WorkletGlobalScope {\n  readonly currentFrame: number;\n  readonly currentTime: number;\n  readonly sampleRate: number;\n  registerProcessor(name: string, processorCtor: AudioWorkletProcessorConstructor): void;\n}\n\ndeclare var AudioWorkletGlobalScope: {\n  prototype: AudioWorkletGlobalScope;\n  new(): AudioWorkletGlobalScope;\n};\n\ninterface AudioWorkletProcessorConstructor {\n  new (options: any): AudioWorkletProcessorImpl;\n}\n\ndeclare function registerProcessor(name: string, processorCtor: AudioWorkletProcessorConstructor): void;\n/* eslint-enable no-var, @typescript-eslint/prefer-function-type, @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions, @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention */\n\nexport class RealTimeBpmProcessor extends AudioWorkletProcessor {\n  aggregate: (pcmData: Float32Array) => AggregateData;\n  realTimeBpmAnalyzer: RealTimeBpmAnalyzer;\n  stopped = false;\n\n  constructor(options: AudioWorkletProcessorParameters) {\n    super(options);\n\n    this.aggregate = chunckAggregator();\n    this.realTimeBpmAnalyzer = new RealTimeBpmAnalyzer(options.processorOptions);\n\n    this.port.addEventListener('message', this.onMessage.bind(this));\n    this.port.start();\n  }\n\n  /**\n   * Handle message event\n   * @param event Contain event data from main process\n   */\n  onMessage(event: RealtimeBpmAnalyzerEvents): void {\n    // Handle custom event RESET\n    if (event.data.message === 'RESET') {\n      console.log('[processor.onMessage] RESET');\n      this.aggregate = chunckAggregator();\n      this.stopped = false;\n      this.realTimeBpmAnalyzer.reset();\n    }\n\n    if (event.data.message === 'STOP') {\n      console.log('[processor.onMessage] STOP');\n      this.aggregate = chunckAggregator();\n      this.stopped = true;\n      this.realTimeBpmAnalyzer.reset();\n    }\n  }\n\n  /**\n   * Process function to handle chunks of data\n   * @param inputs Inputs (the data we need to process)\n   * @param _outputs Outputs (not useful for now)\n   * @param _parameters Parameters\n   * @returns Process ended successfully\n   */\n  process(inputs: Float32Array[][], _outputs: Float32Array[][], _parameters: Record<string, Float32Array>): boolean {\n    const currentChunk = inputs[0][0];\n\n    if (this.stopped) {\n      return true;\n    }\n\n    if (!currentChunk) {\n      return true;\n    }\n\n    const {isBufferFull, buffer, bufferSize} = this.aggregate(currentChunk);\n\n    if (isBufferFull) {\n      // The variable sampleRate is global ! thanks to the AudioWorkletProcessor\n      this.realTimeBpmAnalyzer.analyzeChunck({audioSampleRate: sampleRate, channelData: buffer, bufferSize, postMessage: event => {\n        this.port.postMessage(event);\n      }}).catch((error: unknown) => {\n        console.error(error);\n      });\n    }\n\n    return true;\n  }\n}\n\n/**\n * Mandatory Registration to use the processor\n */\nregisterProcessor(realtimeBpmProcessorName, RealTimeBpmProcessor);\n\nexport default {};\n"],
  "mappings": "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",
  "names": ["realtimeBpmProcessorName", "descendingOverThresholds", "onThreshold", "minValidThreshold", "startThreshold", "thresholdStep", "threshold", "generateValidPeaksModel", "object", "generateNextIndexPeaksModel", "chunckAggregator", "_bytesWritten", "buffer", "initBuffer", "isBufferFull", "flush", "pcmData", "newBuffer", "computeIndexesToSkip", "durationSeconds", "sampleRate", "findPeaksAtThreshold", "audioSampleRate", "data", "threshold", "offset", "peaks", "skipForwardIndexes", "computeIndexesToSkip", "length", "i", "computeBpm", "audioSampleRate", "data", "minPeaks", "hasPeaks", "foundThreshold", "descendingOverThresholds", "threshold", "intervals", "identifyIntervals", "tempos", "groupByTempo", "getTopCandidates", "candidates", "length", "a", "b", "identifyIntervals", "peaks", "intervals", "n", "i", "peak", "peakIndex", "interval", "intervalCount", "item", "groupByTempo", "audioSampleRate", "intervalCounts", "tempoCounts", "theoreticalTempo", "tempoCount", "tempo", "initialValue", "generateValidPeaksModel", "generateNextIndexPeaksModel", "RealTimeBpmAnalyzer", "options", "minThreshold", "descendingOverThresholds", "threshold", "audioSampleRate", "channelData", "bufferSize", "postMessage", "currentMaxIndex", "currentMinIndex", "data", "computeBpm", "offsetForNextPeak", "peaks", "atThreshold", "findPeaksAtThreshold", "relativeChunkPeak", "index", "RealTimeBpmProcessor", "options", "chunckAggregator", "RealTimeBpmAnalyzer", "event", "inputs", "_outputs", "_parameters", "currentChunk", "isBufferFull", "buffer", "bufferSize", "error", "realtimeBpmProcessorName", "realtime_bpm_processor_default"]
}
