{
  "version": 3,
  "sources": ["../src/consts.ts", "../src/generated-processor.ts", "../src/utils.ts", "../src/analyzer.ts", "../src/realtime-bpm-analyzer.ts", "../src/index.ts"],
  "sourcesContent": ["export const realtimeBpmProcessorName = 'realtime-bpm-processor';\nexport const startThreshold = 0.95;\nexport const minValidThreshold = 0.2;\nexport const minPeaks = 15;\nexport const thresholdStep = 0.05;\nexport const frequencyValue = 200;\nexport const qualityValue = 1;\n\n", "export default `\"use strict\";(()=>{var x=\"realtime-bpm-processor\";async function p(r,o=.2,e=.95,s=.05){let t=e;do if(t-=s,await r(t))break;while(t>o)}function y(r=.2,o=.95,e=.05){let s={},t=o;do t-=e,s[t.toString()]=[];while(t>r);return s}function v(r=.2,o=.95,e=.05){let s={},t=o;do t-=e,s[t.toString()]=0;while(t>r);return s}function m(){let o=0,e=new Float32Array(0);function s(){o=0,e=new Float32Array(0)}function t(){return o===4096}function i(){s()}return function(n){t()&&i();let a=new Float32Array(e.length+n.length);return a.set(e,0),a.set(n,e.length),e=a,o+=n.length,{isBufferFull:t(),buffer:e,bufferSize:4096}}}function B(r,o){return Math.round(r*o)}function b({audioSampleRate:r,data:o,threshold:e,offset:s=0}){let t=[],i=B(.25,r),{length:n}=o;for(let a=s;a<n;a+=1)o[a]>e&&(t.push(a),a+=i);return{peaks:t,threshold:e}}async function I({audioSampleRate:r,data:o}){let e=15,s=!1,t=.2;if(await p(async i=>s?!0:(o[i].length>e&&(s=!0,t=i),!1)),s&&t){let i=O(o[t]),n=S({audioSampleRate:r,intervalCounts:i});return{bpm:C(n),threshold:t}}return{bpm:[],threshold:t}}function C(r,o=5){return r.sort((e,s)=>s.count-e.count).splice(0,o)}function O(r){let o=[];for(let e=0;e<r.length;e++)for(let s=0;s<10;s++){let t=r[e],i=e+s,n=r[i]-t;if(!o.some(l=>l.interval===n?(l.count+=1,l.count):!1)){let l={interval:n,count:1};o.push(l)}}return o}function S({audioSampleRate:r,intervalCounts:o}){let e=[];for(let s of o){if(s.interval===0)continue;s.interval=Math.abs(s.interval);let t=60/(s.interval/r);for(;t<90;)t*=2;for(;t>180;)t/=2;if(t=Math.round(t),!e.some(n=>n.tempo===t?(n.count+=s.count,n.count):!1)){let n={tempo:t,count:s.count,confidence:0};e.push(n)}}return e}var d={minValidThreshold:()=>.2,validPeaks:()=>y(),nextIndexPeaks:()=>v(),skipIndexes:()=>1,effectiveBufferTime:()=>0},f=class{constructor(o={}){this.options={continuousAnalysis:!1,stabilizationTime:2e4,muteTimeInIndexes:1e4,debug:!1};this.minValidThreshold=d.minValidThreshold();this.validPeaks=d.validPeaks();this.nextIndexPeaks=d.nextIndexPeaks();this.skipIndexes=d.skipIndexes();this.effectiveBufferTime=d.effectiveBufferTime();this.computedStabilizationTimeInSeconds=0;Object.assign(this.options,o),this.updateComputedValues()}updateComputedValues(){this.computedStabilizationTimeInSeconds=this.options.stabilizationTime/1e3}reset(){this.minValidThreshold=d.minValidThreshold(),this.validPeaks=d.validPeaks(),this.nextIndexPeaks=d.nextIndexPeaks(),this.skipIndexes=d.skipIndexes(),this.effectiveBufferTime=d.effectiveBufferTime()}async clearValidPeaks(o){this.minValidThreshold=Number.parseFloat(o.toFixed(2)),await p(async e=>(e<o&&this.validPeaks[e]!==void 0&&(delete this.validPeaks[e],delete this.nextIndexPeaks[e]),!1))}async analyzeChunck({audioSampleRate:o,channelData:e,bufferSize:s,postMessage:t}){this.options.debug&&t({message:\"ANALYZE_CHUNK\",data:e}),this.effectiveBufferTime+=s;let i=s*this.skipIndexes,n=i-s;await this.findPeaks({audioSampleRate:o,channelData:e,bufferSize:s,currentMinIndex:n,currentMaxIndex:i,postMessage:t}),this.skipIndexes++;let a=await I({audioSampleRate:o,data:this.validPeaks}),{threshold:l}=a;t({message:\"BPM\",data:a}),this.minValidThreshold<l&&(t({message:\"BPM_STABLE\",data:a}),await this.clearValidPeaks(l)),this.options.continuousAnalysis&&this.effectiveBufferTime/o>this.computedStabilizationTimeInSeconds&&(this.reset(),t({message:\"ANALYZER_RESETED\"}))}async findPeaks({audioSampleRate:o,channelData:e,bufferSize:s,currentMinIndex:t,currentMaxIndex:i,postMessage:n}){await p(async a=>{if(this.nextIndexPeaks[a]>=i)return!1;let l=this.nextIndexPeaks[a]%s,{peaks:c,threshold:h}=b({audioSampleRate:o,data:e,threshold:a,offset:l});if(c.length===0)return!1;for(let F of c){let k=t+F;this.nextIndexPeaks[h]=k+this.options.muteTimeInIndexes,this.validPeaks[h].push(k),this.options.debug&&n({message:\"VALID_PEAK\",data:{threshold:h,index:k}})}return!1},this.minValidThreshold)}};var A=class extends AudioWorkletProcessor{constructor(e){super(e);this.stopped=!1;this.aggregate=m(),this.realTimeBpmAnalyzer=new f(e.processorOptions),this.port.addEventListener(\"message\",this.onMessage.bind(this)),this.port.start()}onMessage(e){e.data.message===\"RESET\"&&(console.log(\"[processor.onMessage] RESET\"),this.aggregate=m(),this.stopped=!1,this.realTimeBpmAnalyzer.reset()),e.data.message===\"STOP\"&&(console.log(\"[processor.onMessage] STOP\"),this.aggregate=m(),this.stopped=!0,this.realTimeBpmAnalyzer.reset())}process(e,s,t){let i=e[0][0];if(this.stopped||!i)return!0;let{isBufferFull:n,buffer:a,bufferSize:l}=this.aggregate(i);return n&&this.realTimeBpmAnalyzer.analyzeChunck({audioSampleRate:sampleRate,channelData:a,bufferSize:l,postMessage:c=>{this.port.postMessage(c)}}).catch(c=>{console.error(c)}),!0}};registerProcessor(x,A);var L={};})();\n//# sourceMappingURL=realtime-bpm-processor.js.map\n`;\n", "import * as consts from './consts';\nimport type {Peaks, ValidPeaks, NextIndexPeaks, OnThresholdFunction, AggregateData} from './types';\n\n/**\n * Loop between .9 and minValidThreshold at .2 by default, passing the threshold to the function\n * @param onThreshold Function for each iteration, you must return a boolean, true will exit the loop process\n * @param minValidThreshold minValidThreshold usualy 0.2\n * @param startThreshold startThreshold usualy 0.9\n * @param thresholdStep thresholdStep usuably 0.05\n * @returns A promise that resolves nothing\n */\nexport async function descendingOverThresholds(onThreshold: OnThresholdFunction, minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): Promise<void> {\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    const shouldExit = await onThreshold(threshold);\n    if (shouldExit) {\n      break;\n    }\n  } while (threshold > minValidThreshold);\n}\n\n/**\n * Generate an object with keys as thresholds and will containes validPeaks\n * @param minValidThreshold minValidThreshold usualy 0.2\n * @param startThreshold startThreshold usualy 0.9\n * @param thresholdStep thresholdStep usuably 0.05\n * @returns Collection of validPeaks by thresholds\n */\nexport function generateValidPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): ValidPeaks {\n  const object: Record<string, Peaks> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = [];\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\n/**\n * Generate an object with keys as thresholds and will containes NextIndexPeaks\n * @param minValidThreshold Minimum threshold to reach (we're descending from the startThreshold)\n * @param startThreshold Starting threshold\n * @param thresholdStep Usually 0.05\n * @returns Collection of NextIndexPeaks by thresholds\n */\nexport function generateNextIndexPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): NextIndexPeaks {\n  const object: Record<string, number> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = 0;\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\n/**\n * Creates a function that aggregates incoming PCM data into chunks.\n * @returns A function that accepts PCM data and aggregates it into chunks.\n */\nexport function chunckAggregator(): (pcmData: Float32Array) => AggregateData {\n  const bufferSize = 4096;\n\n  /**\n   * Track the current buffer fill level.\n   */\n  let _bytesWritten = 0;\n\n  /**\n   * Create a buffer of fixed size.\n   */\n  let buffer: Float32Array = new Float32Array(0);\n\n  /**\n   * Initialize the buffer.\n   */\n  function initBuffer(): void {\n    _bytesWritten = 0;\n    buffer = new Float32Array(0);\n  }\n\n  /**\n   * Checks if the buffer is full.\n   * @returns True if the buffer is full, otherwise false.\n   */\n  function isBufferFull(): boolean {\n    return _bytesWritten === bufferSize;\n  }\n\n  /**\n   * Flushes the buffer.\n   */\n  function flush(): void {\n    initBuffer();\n  }\n\n  /**\n   * Aggregates incoming PCM data into chunks.\n   * @param pcmData - The PCM data to be aggregated.\n   * @returns Object containing aggregated data and buffer information.\n   */\n  return function (pcmData: Float32Array): AggregateData {\n    if (isBufferFull()) {\n      flush();\n    }\n\n    const newBuffer = new Float32Array(buffer.length + pcmData.length);\n    newBuffer.set(buffer, 0);\n    newBuffer.set(pcmData, buffer.length);\n    buffer = newBuffer;\n    _bytesWritten += pcmData.length;\n\n    return {\n      isBufferFull: isBufferFull(),\n      buffer,\n      bufferSize,\n    };\n  };\n}\n\n/**\n * Computes the number of indexes we need to skip based on sampleRate\n * @param durationSeconds Duration expressed in seconds\n * @param sampleRate Sample rate, typically 48000, 441000, etc\n * @returns The number of indexes we need to skip\n */\nexport function computeIndexesToSkip(durationSeconds: number, sampleRate: number): number {\n  return Math.round(durationSeconds * sampleRate);\n}\n", "import {descendingOverThresholds} from './utils';\nimport type {\n  Peaks,\n  PeaksAndThreshold,\n  BpmCandidates,\n  Interval,\n  Tempo,\n  Threshold,\n  AnalyzerFindPeaksOptions,\n  AnalyzerGroupByTempoOptions,\n  AnalyzerComputeBpmOptions,\n  BiquadFilterOptions,\n  AnalyzerFindPeaksAtTheshold,\n} from './types';\nimport * as consts from './consts';\nimport * as utils from './utils';\n\n/**\n * Find peaks when the signal if greater than the threshold, then move 10_000 indexes (represents ~0.23s) to ignore the descending phase of the parabol\n * @param options - AnalyzerFindPeaksAtTheshold\n * @param options.audioSampleRate - Sample rate\n * @param options.data - Buffer channel data\n * @param options.threshold - Threshold for qualifying as a peak\n * @param options.offset - Position where we start to loop\n * @returns Peaks found that are greater than the threshold\n */\nexport function findPeaksAtThreshold({\n  audioSampleRate,\n  data,\n  threshold,\n  offset = 0,\n}: AnalyzerFindPeaksAtTheshold): PeaksAndThreshold {\n  const peaks: Peaks = [];\n  const skipForwardIndexes = utils.computeIndexesToSkip(0.25, audioSampleRate);\n\n  const {length} = data;\n\n  /**\n   * Identify peaks that are greater than the threshold, adding them to the collection\n   */\n  for (let i = offset; i < length; i += 1) {\n    if (data[i] > threshold) {\n      peaks.push(i);\n\n      /**\n       * Skip forward ~0.25s to pass this peak\n       */\n      i += skipForwardIndexes;\n    }\n  }\n\n  return {\n    peaks,\n    threshold,\n  };\n}\n\n/**\n * Find the minimum amount of peaks from top to bottom threshold, it's necessary to analyze at least 10seconds at 90bpm\n * @param options - AnalyzerFindPeaksOptions\n * @param options.audioSampleRate - Sample rate\n * @param options.channelData - Channel data\n * @returns Suffisent amount of peaks in order to continue further the process\n */\nexport async function findPeaks({\n  audioSampleRate,\n  channelData,\n}: AnalyzerFindPeaksOptions): Promise<PeaksAndThreshold> {\n  let validPeaks: Peaks = [];\n  let validThreshold = 0;\n\n  await descendingOverThresholds(async threshold => {\n    const {peaks} = findPeaksAtThreshold({audioSampleRate, data: channelData, threshold});\n\n    /**\n     * Loop over peaks\n     */\n    if (peaks.length < consts.minPeaks) {\n      return false;\n    }\n\n    validPeaks = peaks;\n    validThreshold = threshold;\n\n    return true;\n  });\n\n  return {\n    peaks: validPeaks,\n    threshold: validThreshold,\n  };\n}\n\n/**\n * Helpfull function to create standard and shared lowpass and highpass filters\n * Important Note: The original library wasn't using properly the lowpass filter and it was not applied at all.\n * This method should not be used unitl more research and documented tests will be acheived.\n * @param context - AudioContext instance\n * @param options - Optionnal BiquadFilterOptions\n * @returns BiquadFilterNode\n */\nexport function getBiquadFilter(context: OfflineAudioContext | AudioContext, options?: BiquadFilterOptions): BiquadFilterNode {\n  const lowpass = context.createBiquadFilter();\n\n  lowpass.type = 'lowpass';\n  lowpass.frequency.value = options?.frequencyValue ?? consts.frequencyValue;\n  lowpass.Q.value = options?.qualityValue ?? consts.qualityValue;\n\n  return lowpass;\n}\n\n/**\n * Apply to the source a biquad lowpass filter\n * @param buffer - Audio buffer\n * @param options - Optionnal BiquadFilterOptions\n * @returns A Promise that resolves an AudioBuffer instance\n */\nexport async function getOfflineLowPassSource(buffer: AudioBuffer, options?: BiquadFilterOptions): Promise<AudioBuffer> {\n  const {length, numberOfChannels, sampleRate} = buffer;\n  const offlineAudioContext = new OfflineAudioContext(numberOfChannels, length, sampleRate);\n\n  /**\n   * Create buffer source\n   */\n  const source = offlineAudioContext.createBufferSource();\n  source.buffer = buffer;\n\n  const lowpass = getBiquadFilter(offlineAudioContext, options);\n\n  /**\n   * Pipe the song into the filter, and the filter into the offline context\n   */\n  source.connect(lowpass);\n  lowpass.connect(offlineAudioContext.destination);\n\n  source.start(0);\n\n  const audioBuffer = await offlineAudioContext.startRendering();\n\n  return audioBuffer;\n}\n\n/**\n * Return the computed bpm from data\n * @param options - AnalyzerComputeBpmOptions\n * @param options.data - Contain valid peaks\n * @param options.audioSampleRate - Audio sample rate\n * @returns A Promise that resolves BPM Candidates\n */\nexport async function computeBpm({\n  audioSampleRate,\n  data,\n}: AnalyzerComputeBpmOptions): Promise<BpmCandidates> {\n  const minPeaks = consts.minPeaks;\n\n  /**\n   * Flag to fix Object.keys looping\n   */\n  let hasPeaks = false;\n  let foundThreshold = consts.minValidThreshold;\n\n  await descendingOverThresholds(async (threshold: Threshold) => {\n    if (hasPeaks) {\n      return true;\n    }\n\n    if (data[threshold].length > minPeaks) {\n      hasPeaks = true;\n      foundThreshold = threshold;\n    }\n\n    return false;\n  });\n\n  if (hasPeaks && foundThreshold) {\n    const intervals = identifyIntervals(data[foundThreshold]);\n    const tempos = groupByTempo({audioSampleRate, intervalCounts: intervals});\n    const candidates = getTopCandidates(tempos);\n\n    const bpmCandidates: BpmCandidates = {\n      bpm: candidates,\n      threshold: foundThreshold,\n    };\n\n    return bpmCandidates;\n  }\n\n  return {\n    bpm: [],\n    threshold: foundThreshold,\n  };\n}\n\n/**\n * Sort results by count and return top candidate\n * @param candidates - BPMs with count\n * @param length - Amount of returned candidates (default: 5)\n * @returns Returns the 5 top candidates with highest counts\n */\nexport function getTopCandidates(candidates: Tempo[], length = 5): Tempo[] {\n  return candidates.sort((a, b) => (b.count - a.count)).splice(0, length);\n}\n\n/**\n * Gets the top candidate from the array\n * @param candidates - BPMs with counts.\n * @returns Returns the top candidate with the highest count.\n */\nexport function getTopCandidate(candidates: Tempo[]): number {\n  if (candidates.length === 0) {\n    throw new Error('Could not find enough samples for a reliable detection.');\n  }\n\n  const [first] = candidates.sort((a, b) => (b.count - a.count));\n\n  return first.tempo;\n}\n\n/**\n * Identify intervals between bass peaks\n * @param peaks - Array of qualified bass peaks\n * @returns Return a collection of intervals between peaks\n */\nexport function identifyIntervals(peaks: Peaks): Interval[] {\n  const intervals: Interval[] = [];\n\n  for (let n = 0; n < peaks.length; n++) {\n    for (let i = 0; i < 10; i++) {\n      const peak = peaks[n];\n      const peakIndex = n + i;\n      const interval = peaks[peakIndex] - peak;\n\n      /**\n       * Try and find a matching interval and increase it's count\n       */\n      const foundInterval = intervals.some((intervalCount: Interval) => {\n        if (intervalCount.interval === interval) {\n          intervalCount.count += 1;\n          return intervalCount.count;\n        }\n\n        return false;\n      });\n\n      /**\n       * Add the interval to the collection if it's unique\n       */\n      if (!foundInterval) {\n        const item: Interval = {\n          interval,\n          count: 1,\n        };\n        intervals.push(item);\n      }\n    }\n  }\n\n  return intervals;\n}\n\n/**\n * Figure out best possible tempo candidates\n * @param options - AnalyzerGroupByTempoOptions\n * @param options.audioSampleRate - Audio sample rate\n * @param options.intervalCounts - List of identified intervals\n * @returns Intervals grouped with similar values\n */\nexport function groupByTempo({\n  audioSampleRate,\n  intervalCounts,\n}: AnalyzerGroupByTempoOptions): Tempo[] {\n  const tempoCounts: Tempo[] = [];\n\n  for (const intervalCount of intervalCounts) {\n    /**\n     * Skip if interval is equal 0\n     */\n    if (intervalCount.interval === 0) {\n      continue;\n    }\n\n    intervalCount.interval = Math.abs(intervalCount.interval);\n\n    /**\n     * Convert an interval to tempo\n     */\n    let theoreticalTempo = (60 / (intervalCount.interval / audioSampleRate));\n\n    /**\n     * Adjust the tempo to fit within the 90-180 BPM range\n     */\n    while (theoreticalTempo < 90) {\n      theoreticalTempo *= 2;\n    }\n\n    while (theoreticalTempo > 180) {\n      theoreticalTempo /= 2;\n    }\n\n    /**\n     * Round to legible integer\n     */\n    theoreticalTempo = Math.round(theoreticalTempo);\n\n    /**\n     * See if another interval resolved to the same tempo\n     */\n    const foundTempo: boolean = tempoCounts.some((tempoCount: Tempo) => {\n      if (tempoCount.tempo === theoreticalTempo) {\n        tempoCount.count += intervalCount.count;\n        return tempoCount.count;\n      }\n\n      return false;\n    });\n\n    /**\n     * Add a unique tempo to the collection\n     */\n    if (!foundTempo) {\n      const tempo: Tempo = {\n        tempo: theoreticalTempo,\n        count: intervalCount.count,\n        confidence: 0,\n      };\n\n      tempoCounts.push(tempo);\n    }\n  }\n\n  return tempoCounts;\n}\n\n/**\n * Fastest way to detect the BPM from an AudioBuffer\n * @param originalBuffer - AudioBuffer\n * @param options - BiquadFilterOptions\n * @returns Returns the best candidates\n */\nexport async function analyzeFullBuffer(originalBuffer: AudioBuffer, options?: BiquadFilterOptions): Promise<Tempo[]> {\n  const buffer = await getOfflineLowPassSource(originalBuffer, options);\n  const channelData = buffer.getChannelData(0);\n  const {peaks} = await findPeaks({audioSampleRate: buffer.sampleRate, channelData});\n  const intervals = identifyIntervals(peaks);\n  const tempos = groupByTempo({audioSampleRate: buffer.sampleRate, intervalCounts: intervals});\n  const topCandidates = getTopCandidates(tempos);\n\n  return topCandidates;\n}\n", "import {findPeaksAtThreshold, computeBpm} from './analyzer';\nimport type {\n  RealTimeBpmAnalyzerOptions,\n  RealTimeBpmAnalyzerParameters,\n  ValidPeaks,\n  NextIndexPeaks,\n  BpmCandidates,\n  Threshold,\n  RealtimeFindPeaksOptions,\n  RealtimeAnalyzeChunkOptions,\n} from './types';\nimport {\n  generateValidPeaksModel,\n  generateNextIndexPeaksModel,\n  descendingOverThresholds,\n} from './utils';\nimport * as consts from './consts';\n\n/**\n * Initial value of key parameters of the analyzer\n */\nconst initialValue = {\n  minValidThreshold: () => consts.minValidThreshold,\n  validPeaks: () => generateValidPeaksModel(),\n  nextIndexPeaks: () => generateNextIndexPeaksModel(),\n  skipIndexes: () => 1,\n  effectiveBufferTime: () => 0,\n};\n\nexport class RealTimeBpmAnalyzer {\n  /**\n   * Default configuration\n   */\n  options: RealTimeBpmAnalyzerOptions = {\n    continuousAnalysis: false,\n    stabilizationTime: 20000,\n    muteTimeInIndexes: 10000,\n    debug: false,\n  };\n\n  /**\n   * Minimum valid threshold, below this level result would be irrelevant.\n   */\n  minValidThreshold: Threshold = initialValue.minValidThreshold();\n  /**\n   * Contain all valid peaks\n   */\n  validPeaks: ValidPeaks = initialValue.validPeaks();\n  /**\n   * Next index (+10000 ...) to take care about peaks\n   */\n  nextIndexPeaks: NextIndexPeaks = initialValue.nextIndexPeaks();\n  /**\n   * Number / Position of chunks\n   */\n  skipIndexes: number = initialValue.skipIndexes();\n  effectiveBufferTime: number = initialValue.effectiveBufferTime();\n  /**\n   * Computed values\n   */\n  computedStabilizationTimeInSeconds = 0;\n\n  constructor(options: RealTimeBpmAnalyzerParameters = {}) {\n    Object.assign(this.options, options);\n    this.updateComputedValues();\n  }\n\n  /**\n   * Update the computed values\n   */\n  updateComputedValues() {\n    this.computedStabilizationTimeInSeconds = this.options.stabilizationTime / 1000;\n  }\n\n  /**\n   * Reset BPM computation properties to get a fresh start\n   */\n  reset(): void {\n    this.minValidThreshold = initialValue.minValidThreshold();\n    this.validPeaks = initialValue.validPeaks();\n    this.nextIndexPeaks = initialValue.nextIndexPeaks();\n    this.skipIndexes = initialValue.skipIndexes();\n    this.effectiveBufferTime = initialValue.effectiveBufferTime();\n  }\n\n  /**\n   * Remve all validPeaks between the minThreshold pass in param to optimize the weight of datas\n   * @param minThreshold - Value between 0.9 and 0.2\n   */\n  async clearValidPeaks(minThreshold: Threshold): Promise<void> {\n    this.minValidThreshold = Number.parseFloat(minThreshold.toFixed(2));\n\n    await descendingOverThresholds(async threshold => {\n      if (threshold < minThreshold && this.validPeaks[threshold] !== undefined) {\n        delete this.validPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n        delete this.nextIndexPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * Attach this function to an audioprocess event on a audio/video node to compute BPM / Tempo in realtime\n   * @param options - RealtimeAnalyzeChunkOptions\n   * @param options.audioSampleRate - Audio sample rate (44100)\n   * @param options.channelData - Channel data\n   * @param options.bufferSize - Buffer size (4096)\n   * @param options.postMessage - Function to post a message to the processor node\n   */\n  async analyzeChunck({audioSampleRate, channelData, bufferSize, postMessage}: RealtimeAnalyzeChunkOptions): Promise<void> {\n    if (this.options.debug) {\n      postMessage({message: 'ANALYZE_CHUNK', data: channelData});\n    }\n\n    /**\n     * We are summing up the size of each analyzed chunks in order to compute later if we reached the stabilizationTime\n     * Ex: effectiveBufferTime / audioSampleRate = timeInSeconds (1000000/44100=22s)\n     */\n    this.effectiveBufferTime += bufferSize;\n\n    /**\n     * Compute the maximum index with all previous chunks\n     */\n    const currentMaxIndex = bufferSize * this.skipIndexes;\n\n    /**\n     * Compute the minimum index with all previous chunks\n     */\n    const currentMinIndex = currentMaxIndex - bufferSize;\n\n    /**\n     * Mutate nextIndexPeaks and validPeaks if possible\n     */\n    await this.findPeaks({\n      audioSampleRate,\n      channelData,\n      bufferSize,\n      currentMinIndex,\n      currentMaxIndex,\n      postMessage,\n    });\n\n    /**\n     * Increment chunk\n     */\n    this.skipIndexes++;\n\n    const data: BpmCandidates = await computeBpm({audioSampleRate, data: this.validPeaks});\n    const {threshold} = data;\n    postMessage({message: 'BPM', data});\n\n    /**\n     * If the results found have a \"high\" threshold, the BPM is considered stable/strong\n     */\n    if (this.minValidThreshold < threshold) {\n      postMessage({message: 'BPM_STABLE', data});\n      await this.clearValidPeaks(threshold);\n    }\n\n    /**\n     * After x time, we reinit the analyzer\n     */\n    if (this.options.continuousAnalysis && this.effectiveBufferTime / audioSampleRate > this.computedStabilizationTimeInSeconds) {\n      this.reset();\n      postMessage({message: 'ANALYZER_RESETED'});\n    }\n  }\n\n  /**\n   * Find the best threshold with enought peaks\n   * @param options - Options for finding peaks\n   * @param options.audioSampleRate - Sample rate\n   * @param options.channelData - Channel data\n   * @param options.bufferSize - Buffer size\n   * @param options.currentMinIndex - Current minimum index\n   * @param options.currentMaxIndex - Current maximum index\n   * @param options.postMessage - Function to post a message to the processor node\n   */\n  async findPeaks({\n    audioSampleRate,\n    channelData,\n    bufferSize,\n    currentMinIndex,\n    currentMaxIndex,\n    postMessage,\n  }: RealtimeFindPeaksOptions): Promise<void> {\n    await descendingOverThresholds(async threshold => {\n      if (this.nextIndexPeaks[threshold] >= currentMaxIndex) {\n        return false;\n      }\n\n      /**\n       * Get the next index in the next chunk\n       */\n      const offsetForNextPeak = this.nextIndexPeaks[threshold] % bufferSize; // 0 - 4095\n\n      const {peaks, threshold: atThreshold} = findPeaksAtThreshold({audioSampleRate, data: channelData, threshold, offset: offsetForNextPeak});\n\n      /**\n       * Loop over peaks\n       */\n      if (peaks.length === 0) {\n        return false;\n      }\n\n      for (const relativeChunkPeak of peaks) {\n        const index = currentMinIndex + relativeChunkPeak;\n\n        /**\n         * Add current Index + muteTimeInIndexes (10000/44100=0.22s)\n         */\n        this.nextIndexPeaks[atThreshold] = index + this.options.muteTimeInIndexes;\n\n        /**\n         * Store valid relativeChunkPeak Indexes\n         */\n        this.validPeaks[atThreshold].push(index);\n\n        if (this.options.debug) {\n          postMessage({\n            message: 'VALID_PEAK',\n            data: {\n              threshold: atThreshold,\n              index,\n            },\n          });\n        }\n      }\n\n      return false;\n    }, this.minValidThreshold);\n  }\n}\n", "import {realtimeBpmProcessorName} from './consts';\nimport realtimeBpmProcessorContent from './generated-processor';\nimport {type RealTimeBpmAnalyzerParameters} from './types';\n\nexport * from './realtime-bpm-analyzer';\nexport {analyzeFullBuffer, getBiquadFilter} from './analyzer';\nexport * from './types';\n\n/**\n * Create the RealTimeBpmProcessor needed to run the realtime strategy\n * @param audioContext AudioContext instance\n * @param processorOptions RealTimeBpmAnalyzerParameters\n * @returns An AudioWorkletNode instance\n */\nexport async function createRealTimeBpmProcessor(audioContext: AudioContext, processorOptions?: RealTimeBpmAnalyzerParameters): Promise<AudioWorkletNode> {\n  const processorNode = await setupAudioWorkletNode(audioContext, realtimeBpmProcessorName, processorOptions);\n\n  await audioContext.resume();\n\n  return processorNode;\n}\n\n/**\n * Creates AudioWorkletNode for the Processor\n * @param audioContext AudioContext instance\n * @param processorName Name of the audio processor, without the extension\n * @param processorOptions RealTimeBpmAnalyzerParameters\n * @returns Recording node related components for the app.\n */\nasync function setupAudioWorkletNode(audioContext: AudioContext, processorName: string, processorOptions?: RealTimeBpmAnalyzerParameters): Promise<AudioWorkletNode> {\n  const blob = new Blob([realtimeBpmProcessorContent], {type: 'application/javascript'});\n\n  const objectUrl = URL.createObjectURL(blob);\n\n  await audioContext.audioWorklet.addModule(objectUrl);\n\n  const audioWorkletNode = new AudioWorkletNode(audioContext, processorName, {\n    processorOptions,\n  });\n\n  return audioWorkletNode;\n}\n"],
  "mappings": "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",
  "names": ["realtimeBpmProcessorName", "generated_processor_default", "descendingOverThresholds", "onThreshold", "minValidThreshold", "startThreshold", "thresholdStep", "threshold", "generateValidPeaksModel", "object", "generateNextIndexPeaksModel", "computeIndexesToSkip", "durationSeconds", "sampleRate", "findPeaksAtThreshold", "audioSampleRate", "data", "threshold", "offset", "peaks", "skipForwardIndexes", "computeIndexesToSkip", "length", "i", "findPeaks", "channelData", "validPeaks", "validThreshold", "descendingOverThresholds", "getBiquadFilter", "context", "options", "lowpass", "getOfflineLowPassSource", "buffer", "numberOfChannels", "sampleRate", "offlineAudioContext", "source", "computeBpm", "minPeaks", "hasPeaks", "foundThreshold", "intervals", "identifyIntervals", "tempos", "groupByTempo", "getTopCandidates", "candidates", "a", "b", "identifyIntervals", "peaks", "intervals", "n", "i", "peak", "peakIndex", "interval", "intervalCount", "item", "groupByTempo", "audioSampleRate", "intervalCounts", "tempoCounts", "theoreticalTempo", "tempoCount", "tempo", "analyzeFullBuffer", "originalBuffer", "options", "buffer", "getOfflineLowPassSource", "channelData", "findPeaks", "tempos", "getTopCandidates", "initialValue", "generateValidPeaksModel", "generateNextIndexPeaksModel", "RealTimeBpmAnalyzer", "options", "minThreshold", "descendingOverThresholds", "threshold", "audioSampleRate", "channelData", "bufferSize", "postMessage", "currentMaxIndex", "currentMinIndex", "data", "computeBpm", "offsetForNextPeak", "peaks", "atThreshold", "findPeaksAtThreshold", "relativeChunkPeak", "index", "createRealTimeBpmProcessor", "audioContext", "processorOptions", "processorNode", "setupAudioWorkletNode", "realtimeBpmProcessorName", "processorName", "blob", "generated_processor_default", "objectUrl"]
}
