declare module "src/consts" {
    export const realtimeBpmProcessorName = "realtime-bpm-processor";
    export const startThreshold = 0.95;
    export const minValidThreshold = 0.2;
    export const minPeaks = 15;
    export const thresholdStep = 0.05;
    export const frequencyValue = 200;
    export const qualityValue = 1;
}
declare module "src/types" {
    /**
     * Events
     */
    export type EventBuilder<S extends string, T = undefined> = T extends undefined ? {
        message: S;
    } : {
        message: S;
        data: T;
    };
    export type EventMessageBuilder<T> = {
        data: T;
    };
    export type AnalyzeChunkEvent = EventBuilder<'ANALYZE_CHUNK', Float32Array>;
    export type AnalyzeChunkEventMessage = EventMessageBuilder<AnalyzeChunkEvent>;
    export type ValidPeakEvent = EventBuilder<'VALID_PEAK', {
        threshold: Threshold;
        index: number;
    }>;
    export type ValidPeakEventMessage = EventMessageBuilder<ValidPeakEvent>;
    export type DebugEvent = EventBuilder<'DEBUG', unknown>;
    export type DebugEventDataMessage = EventMessageBuilder<DebugEvent>;
    export type BpmEvent = EventBuilder<'BPM' | 'BPM_STABLE', BpmCandidates>;
    export type BpmEventMessage = EventMessageBuilder<BpmEvent>;
    export type AnalyzerResetedEvent = EventBuilder<'ANALYZER_RESETED'>;
    export type AnalyzerResetedEventMessage = EventMessageBuilder<AnalyzerResetedEvent>;
    export type ResetEvent = EventBuilder<'RESET'>;
    export type StopEvent = EventBuilder<'STOP'>;
    export type RealtimeBpmAnalyzerEvents = {
        data: ResetEvent | StopEvent;
    };
    export type PostMessageEvents = BpmEvent | AnalyzerResetedEvent | AnalyzeChunkEvent | ValidPeakEvent | DebugEvent;
    /**
     * Analyzer Types
     */
    export type Threshold = number;
    export type Peaks = number[];
    export type PeaksAndThreshold = {
        peaks: Peaks;
        threshold: Threshold;
    };
    export type BpmCandidates = {
        bpm: Tempo[];
        threshold: Threshold;
    };
    export type Interval = {
        interval: number;
        count: number;
    };
    export type Group = {
        tempo: number;
        count: number;
    };
    export type Tempo = {
        tempo: number;
        count: number;
        confidence: number;
    };
    export type RealTimeBpmAnalyzerParameters = {
        continuousAnalysis?: boolean;
        stabilizationTime?: number;
        muteTimeInIndexes?: number;
        debug?: boolean;
    };
    export type RealTimeBpmAnalyzerOptions = {
        continuousAnalysis: boolean;
        stabilizationTime: number;
        muteTimeInIndexes: number;
        debug: boolean;
    };
    export type AnalyzerGroupByTempoOptions = {
        audioSampleRate: number;
        intervalCounts: Interval[];
    };
    export type AnalyzerFindPeaksOptions = {
        audioSampleRate: number;
        channelData: Float32Array;
    };
    export type AnalyzerComputeBpmOptions = {
        audioSampleRate: number;
        data: ValidPeaks;
    };
    export type AnalyzerFindPeaksAtTheshold = {
        audioSampleRate: number;
        data: Float32Array;
        threshold: Threshold;
        offset?: number;
    };
    export type RealtimeFindPeaksOptions = {
        audioSampleRate: number;
        channelData: Float32Array;
        bufferSize: number;
        currentMinIndex: number;
        currentMaxIndex: number;
        postMessage: (data: PostMessageEvents) => void;
    };
    export type RealtimeAnalyzeChunkOptions = {
        audioSampleRate: number;
        channelData: Float32Array;
        bufferSize: number;
        postMessage: (data: PostMessageEvents) => void;
    };
    export type ValidPeaks = Record<string, Peaks>;
    export type NextIndexPeaks = Record<string, number>;
    export type OnThresholdFunction = (threshold: Threshold) => Promise<boolean>;
    export type AggregateData = {
        isBufferFull: boolean;
        buffer: Float32Array;
        bufferSize: number;
    };
    export type NormalizedFilters = {
        lowpass: BiquadFilterNode;
        highpass: BiquadFilterNode;
    };
    export type BiquadFilterOptions = {
        frequencyValue?: number;
        qualityValue?: number;
    };
}
declare module "src/utils" {
    import type { ValidPeaks, NextIndexPeaks, OnThresholdFunction, AggregateData } from "src/types";
    /**
     * Loop between .9 and minValidThreshold at .2 by default, passing the threshold to the function
     * @param onThreshold Function for each iteration, you must return a boolean, true will exit the loop process
     * @param minValidThreshold minValidThreshold usualy 0.2
     * @param startThreshold startThreshold usualy 0.9
     * @param thresholdStep thresholdStep usuably 0.05
     * @returns A promise that resolves nothing
     */
    export function descendingOverThresholds(onThreshold: OnThresholdFunction, minValidThreshold?: number, startThreshold?: number, thresholdStep?: number): Promise<void>;
    /**
     * Generate an object with keys as thresholds and will containes validPeaks
     * @param minValidThreshold minValidThreshold usualy 0.2
     * @param startThreshold startThreshold usualy 0.9
     * @param thresholdStep thresholdStep usuably 0.05
     * @returns Collection of validPeaks by thresholds
     */
    export function generateValidPeaksModel(minValidThreshold?: number, startThreshold?: number, thresholdStep?: number): ValidPeaks;
    /**
     * Generate an object with keys as thresholds and will containes NextIndexPeaks
     * @param minValidThreshold Minimum threshold to reach (we're descending from the startThreshold)
     * @param startThreshold Starting threshold
     * @param thresholdStep Usually 0.05
     * @returns Collection of NextIndexPeaks by thresholds
     */
    export function generateNextIndexPeaksModel(minValidThreshold?: number, startThreshold?: number, thresholdStep?: number): NextIndexPeaks;
    /**
     * Creates a function that aggregates incoming PCM data into chunks.
     * @returns A function that accepts PCM data and aggregates it into chunks.
     */
    export function chunckAggregator(): (pcmData: Float32Array) => AggregateData;
    /**
     * Computes the number of indexes we need to skip based on sampleRate
     * @param durationSeconds Duration expressed in seconds
     * @param sampleRate Sample rate, typically 48000, 441000, etc
     * @returns The number of indexes we need to skip
     */
    export function computeIndexesToSkip(durationSeconds: number, sampleRate: number): number;
}
declare module "src/analyzer" {
    import type { Peaks, PeaksAndThreshold, BpmCandidates, Interval, Tempo, AnalyzerFindPeaksOptions, AnalyzerGroupByTempoOptions, AnalyzerComputeBpmOptions, BiquadFilterOptions, AnalyzerFindPeaksAtTheshold } from "src/types";
    /**
     * Find peaks when the signal if greater than the threshold, then move 10_000 indexes (represents ~0.23s) to ignore the descending phase of the parabol
     * @param options - AnalyzerFindPeaksAtTheshold
     * @param options.audioSampleRate - Sample rate
     * @param options.data - Buffer channel data
     * @param options.threshold - Threshold for qualifying as a peak
     * @param options.offset - Position where we start to loop
     * @returns Peaks found that are greater than the threshold
     */
    export function findPeaksAtThreshold({ audioSampleRate, data, threshold, offset, }: AnalyzerFindPeaksAtTheshold): PeaksAndThreshold;
    /**
     * Find the minimum amount of peaks from top to bottom threshold, it's necessary to analyze at least 10seconds at 90bpm
     * @param options - AnalyzerFindPeaksOptions
     * @param options.audioSampleRate - Sample rate
     * @param options.channelData - Channel data
     * @returns Suffisent amount of peaks in order to continue further the process
     */
    export function findPeaks({ audioSampleRate, channelData, }: AnalyzerFindPeaksOptions): Promise<PeaksAndThreshold>;
    /**
     * Helpfull function to create standard and shared lowpass and highpass filters
     * Important Note: The original library wasn't using properly the lowpass filter and it was not applied at all.
     * This method should not be used unitl more research and documented tests will be acheived.
     * @param context - AudioContext instance
     * @param options - Optionnal BiquadFilterOptions
     * @returns BiquadFilterNode
     */
    export function getBiquadFilter(context: OfflineAudioContext | AudioContext, options?: BiquadFilterOptions): BiquadFilterNode;
    /**
     * Apply to the source a biquad lowpass filter
     * @param buffer - Audio buffer
     * @param options - Optionnal BiquadFilterOptions
     * @returns A Promise that resolves an AudioBuffer instance
     */
    export function getOfflineLowPassSource(buffer: AudioBuffer, options?: BiquadFilterOptions): Promise<AudioBuffer>;
    /**
     * Return the computed bpm from data
     * @param options - AnalyzerComputeBpmOptions
     * @param options.data - Contain valid peaks
     * @param options.audioSampleRate - Audio sample rate
     * @returns A Promise that resolves BPM Candidates
     */
    export function computeBpm({ audioSampleRate, data, }: AnalyzerComputeBpmOptions): Promise<BpmCandidates>;
    /**
     * Sort results by count and return top candidate
     * @param candidates - BPMs with count
     * @param length - Amount of returned candidates (default: 5)
     * @returns Returns the 5 top candidates with highest counts
     */
    export function getTopCandidates(candidates: Tempo[], length?: number): Tempo[];
    /**
     * Gets the top candidate from the array
     * @param candidates - BPMs with counts.
     * @returns Returns the top candidate with the highest count.
     */
    export function getTopCandidate(candidates: Tempo[]): number;
    /**
     * Identify intervals between bass peaks
     * @param peaks - Array of qualified bass peaks
     * @returns Return a collection of intervals between peaks
     */
    export function identifyIntervals(peaks: Peaks): Interval[];
    /**
     * Figure out best possible tempo candidates
     * @param options - AnalyzerGroupByTempoOptions
     * @param options.audioSampleRate - Audio sample rate
     * @param options.intervalCounts - List of identified intervals
     * @returns Intervals grouped with similar values
     */
    export function groupByTempo({ audioSampleRate, intervalCounts, }: AnalyzerGroupByTempoOptions): Tempo[];
    /**
     * Fastest way to detect the BPM from an AudioBuffer
     * @param originalBuffer - AudioBuffer
     * @param options - BiquadFilterOptions
     * @returns Returns the best candidates
     */
    export function analyzeFullBuffer(originalBuffer: AudioBuffer, options?: BiquadFilterOptions): Promise<Tempo[]>;
}
declare module "src/realtime-bpm-analyzer" {
    import type { RealTimeBpmAnalyzerOptions, RealTimeBpmAnalyzerParameters, ValidPeaks, NextIndexPeaks, Threshold, RealtimeFindPeaksOptions, RealtimeAnalyzeChunkOptions } from "src/types";
    export class RealTimeBpmAnalyzer {
        /**
         * Default configuration
         */
        options: RealTimeBpmAnalyzerOptions;
        /**
         * Minimum valid threshold, below this level result would be irrelevant.
         */
        minValidThreshold: Threshold;
        /**
         * Contain all valid peaks
         */
        validPeaks: ValidPeaks;
        /**
         * Next index (+10000 ...) to take care about peaks
         */
        nextIndexPeaks: NextIndexPeaks;
        /**
         * Number / Position of chunks
         */
        skipIndexes: number;
        effectiveBufferTime: number;
        /**
         * Computed values
         */
        computedStabilizationTimeInSeconds: number;
        constructor(options?: RealTimeBpmAnalyzerParameters);
        /**
         * Update the computed values
         */
        updateComputedValues(): void;
        /**
         * Reset BPM computation properties to get a fresh start
         */
        reset(): void;
        /**
         * Remve all validPeaks between the minThreshold pass in param to optimize the weight of datas
         * @param minThreshold - Value between 0.9 and 0.2
         */
        clearValidPeaks(minThreshold: Threshold): Promise<void>;
        /**
         * Attach this function to an audioprocess event on a audio/video node to compute BPM / Tempo in realtime
         * @param options - RealtimeAnalyzeChunkOptions
         * @param options.audioSampleRate - Audio sample rate (44100)
         * @param options.channelData - Channel data
         * @param options.bufferSize - Buffer size (4096)
         * @param options.postMessage - Function to post a message to the processor node
         */
        analyzeChunck({ audioSampleRate, channelData, bufferSize, postMessage }: RealtimeAnalyzeChunkOptions): Promise<void>;
        /**
         * Find the best threshold with enought peaks
         * @param options - Options for finding peaks
         * @param options.audioSampleRate - Sample rate
         * @param options.channelData - Channel data
         * @param options.bufferSize - Buffer size
         * @param options.currentMinIndex - Current minimum index
         * @param options.currentMaxIndex - Current maximum index
         * @param options.postMessage - Function to post a message to the processor node
         */
        findPeaks({ audioSampleRate, channelData, bufferSize, currentMinIndex, currentMaxIndex, postMessage, }: RealtimeFindPeaksOptions): Promise<void>;
    }
}
declare module "processor/realtime-bpm-processor" {
    import { RealTimeBpmAnalyzer } from "src/realtime-bpm-analyzer";
    import type { RealtimeBpmAnalyzerEvents, AggregateData, RealTimeBpmAnalyzerParameters, PostMessageEvents } from "src/types";
    interface AudioWorkletProcessor {
        readonly port: AuthorizedMessagePort;
    }
    interface AuthorizedMessagePort extends MessagePort {
        postMessage(message: PostMessageEvents): void;
    }
    type AudioWorkletProcessorParameters = {
        numberOfInputs: number;
        numberOfOutputs: number;
        processorOptions: RealTimeBpmAnalyzerParameters;
    };
    var AudioWorkletProcessor: {
        prototype: AudioWorkletProcessor;
        new (options?: AudioWorkletProcessorParameters): AudioWorkletProcessor;
    };
    export class RealTimeBpmProcessor extends AudioWorkletProcessor {
        aggregate: (pcmData: Float32Array) => AggregateData;
        realTimeBpmAnalyzer: RealTimeBpmAnalyzer;
        stopped: boolean;
        constructor(options: AudioWorkletProcessorParameters);
        /**
         * Handle message event
         * @param event Contain event data from main process
         */
        onMessage(event: RealtimeBpmAnalyzerEvents): void;
        /**
         * Process function to handle chunks of data
         * @param inputs Inputs (the data we need to process)
         * @param _outputs Outputs (not useful for now)
         * @param _parameters Parameters
         * @returns Process ended successfully
         */
        process(inputs: Float32Array[][], _outputs: Float32Array[][], _parameters: Record<string, Float32Array>): boolean;
    }
    const _default: {};
    export default _default;
}
