import type { Peaks, PeaksAndThreshold, BpmCandidates, Interval, Tempo, AnalyzerFindPeaksOptions, AnalyzerGroupByTempoOptions, AnalyzerComputeBpmOptions, BiquadFilterOptions, AnalyzerFindPeaksAtTheshold } from './types';
/**
 * Find peaks when the signal if greater than the threshold, then move 10_000 indexes (represents ~0.23s) to ignore the descending phase of the parabol
 * @param options - AnalyzerFindPeaksAtTheshold
 * @param options.audioSampleRate - Sample rate
 * @param options.data - Buffer channel data
 * @param options.threshold - Threshold for qualifying as a peak
 * @param options.offset - Position where we start to loop
 * @returns Peaks found that are greater than the threshold
 */
export declare function findPeaksAtThreshold({ audioSampleRate, data, threshold, offset, }: AnalyzerFindPeaksAtTheshold): PeaksAndThreshold;
/**
 * Find the minimum amount of peaks from top to bottom threshold, it's necessary to analyze at least 10seconds at 90bpm
 * @param options - AnalyzerFindPeaksOptions
 * @param options.audioSampleRate - Sample rate
 * @param options.channelData - Channel data
 * @returns Suffisent amount of peaks in order to continue further the process
 */
export declare function findPeaks({ audioSampleRate, channelData, }: AnalyzerFindPeaksOptions): Promise<PeaksAndThreshold>;
/**
 * Helpfull function to create standard and shared lowpass and highpass filters
 * Important Note: The original library wasn't using properly the lowpass filter and it was not applied at all.
 * This method should not be used unitl more research and documented tests will be acheived.
 * @param context - AudioContext instance
 * @param options - Optionnal BiquadFilterOptions
 * @returns BiquadFilterNode
 */
export declare function getBiquadFilter(context: OfflineAudioContext | AudioContext, options?: BiquadFilterOptions): BiquadFilterNode;
/**
 * Apply to the source a biquad lowpass filter
 * @param buffer - Audio buffer
 * @param options - Optionnal BiquadFilterOptions
 * @returns A Promise that resolves an AudioBuffer instance
 */
export declare function getOfflineLowPassSource(buffer: AudioBuffer, options?: BiquadFilterOptions): Promise<AudioBuffer>;
/**
 * Return the computed bpm from data
 * @param options - AnalyzerComputeBpmOptions
 * @param options.data - Contain valid peaks
 * @param options.audioSampleRate - Audio sample rate
 * @returns A Promise that resolves BPM Candidates
 */
export declare function computeBpm({ audioSampleRate, data, }: AnalyzerComputeBpmOptions): Promise<BpmCandidates>;
/**
 * Sort results by count and return top candidate
 * @param candidates - BPMs with count
 * @param length - Amount of returned candidates (default: 5)
 * @returns Returns the 5 top candidates with highest counts
 */
export declare function getTopCandidates(candidates: Tempo[], length?: number): Tempo[];
/**
 * Gets the top candidate from the array
 * @param candidates - BPMs with counts.
 * @returns Returns the top candidate with the highest count.
 */
export declare function getTopCandidate(candidates: Tempo[]): number;
/**
 * Identify intervals between bass peaks
 * @param peaks - Array of qualified bass peaks
 * @returns Return a collection of intervals between peaks
 */
export declare function identifyIntervals(peaks: Peaks): Interval[];
/**
 * Figure out best possible tempo candidates
 * @param options - AnalyzerGroupByTempoOptions
 * @param options.audioSampleRate - Audio sample rate
 * @param options.intervalCounts - List of identified intervals
 * @returns Intervals grouped with similar values
 */
export declare function groupByTempo({ audioSampleRate, intervalCounts, }: AnalyzerGroupByTempoOptions): Tempo[];
/**
 * Fastest way to detect the BPM from an AudioBuffer
 * @param originalBuffer - AudioBuffer
 * @param options - BiquadFilterOptions
 * @returns Returns the best candidates
 */
export declare function analyzeFullBuffer(originalBuffer: AudioBuffer, options?: BiquadFilterOptions): Promise<Tempo[]>;
