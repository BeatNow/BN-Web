{
  "version": 3,
  "sources": ["../../realtime-bpm-analyzer/src/consts.ts", "../../realtime-bpm-analyzer/src/generated-processor.ts", "../../realtime-bpm-analyzer/src/utils.ts", "../../realtime-bpm-analyzer/src/analyzer.ts", "../../realtime-bpm-analyzer/src/realtime-bpm-analyzer.ts", "../../realtime-bpm-analyzer/src/index.ts"],
  "sourcesContent": ["export const realtimeBpmProcessorName = 'realtime-bpm-processor';\nexport const startThreshold = 0.95;\nexport const minValidThreshold = 0.2;\nexport const minPeaks = 15;\nexport const thresholdStep = 0.05;\nexport const frequencyValue = 200;\nexport const qualityValue = 1;\n\n", "export default `\"use strict\";(()=>{var x=\"realtime-bpm-processor\";async function p(r,o=.2,e=.95,s=.05){let t=e;do if(t-=s,await r(t))break;while(t>o)}function y(r=.2,o=.95,e=.05){let s={},t=o;do t-=e,s[t.toString()]=[];while(t>r);return s}function v(r=.2,o=.95,e=.05){let s={},t=o;do t-=e,s[t.toString()]=0;while(t>r);return s}function m(){let o=0,e=new Float32Array(0);function s(){o=0,e=new Float32Array(0)}function t(){return o===4096}function i(){s()}return function(n){t()&&i();let a=new Float32Array(e.length+n.length);return a.set(e,0),a.set(n,e.length),e=a,o+=n.length,{isBufferFull:t(),buffer:e,bufferSize:4096}}}function B(r,o){return Math.round(r*o)}function b({audioSampleRate:r,data:o,threshold:e,offset:s=0}){let t=[],i=B(.25,r),{length:n}=o;for(let a=s;a<n;a+=1)o[a]>e&&(t.push(a),a+=i);return{peaks:t,threshold:e}}async function I({audioSampleRate:r,data:o}){let e=15,s=!1,t=.2;if(await p(async i=>s?!0:(o[i].length>e&&(s=!0,t=i),!1)),s&&t){let i=O(o[t]),n=S({audioSampleRate:r,intervalCounts:i});return{bpm:C(n),threshold:t}}return{bpm:[],threshold:t}}function C(r,o=5){return r.sort((e,s)=>s.count-e.count).splice(0,o)}function O(r){let o=[];for(let e=0;e<r.length;e++)for(let s=0;s<10;s++){let t=r[e],i=e+s,n=r[i]-t;if(!o.some(l=>l.interval===n?(l.count+=1,l.count):!1)){let l={interval:n,count:1};o.push(l)}}return o}function S({audioSampleRate:r,intervalCounts:o}){let e=[];for(let s of o){if(s.interval===0)continue;s.interval=Math.abs(s.interval);let t=60/(s.interval/r);for(;t<90;)t*=2;for(;t>180;)t/=2;if(t=Math.round(t),!e.some(n=>n.tempo===t?(n.count+=s.count,n.count):!1)){let n={tempo:t,count:s.count,confidence:0};e.push(n)}}return e}var d={minValidThreshold:()=>.2,validPeaks:()=>y(),nextIndexPeaks:()=>v(),skipIndexes:()=>1,effectiveBufferTime:()=>0},f=class{constructor(o={}){this.options={continuousAnalysis:!1,stabilizationTime:2e4,muteTimeInIndexes:1e4,debug:!1};this.minValidThreshold=d.minValidThreshold();this.validPeaks=d.validPeaks();this.nextIndexPeaks=d.nextIndexPeaks();this.skipIndexes=d.skipIndexes();this.effectiveBufferTime=d.effectiveBufferTime();this.computedStabilizationTimeInSeconds=0;Object.assign(this.options,o),this.updateComputedValues()}updateComputedValues(){this.computedStabilizationTimeInSeconds=this.options.stabilizationTime/1e3}reset(){this.minValidThreshold=d.minValidThreshold(),this.validPeaks=d.validPeaks(),this.nextIndexPeaks=d.nextIndexPeaks(),this.skipIndexes=d.skipIndexes(),this.effectiveBufferTime=d.effectiveBufferTime()}async clearValidPeaks(o){this.minValidThreshold=Number.parseFloat(o.toFixed(2)),await p(async e=>(e<o&&this.validPeaks[e]!==void 0&&(delete this.validPeaks[e],delete this.nextIndexPeaks[e]),!1))}async analyzeChunck({audioSampleRate:o,channelData:e,bufferSize:s,postMessage:t}){this.options.debug&&t({message:\"ANALYZE_CHUNK\",data:e}),this.effectiveBufferTime+=s;let i=s*this.skipIndexes,n=i-s;await this.findPeaks({audioSampleRate:o,channelData:e,bufferSize:s,currentMinIndex:n,currentMaxIndex:i,postMessage:t}),this.skipIndexes++;let a=await I({audioSampleRate:o,data:this.validPeaks}),{threshold:l}=a;t({message:\"BPM\",data:a}),this.minValidThreshold<l&&(t({message:\"BPM_STABLE\",data:a}),await this.clearValidPeaks(l)),this.options.continuousAnalysis&&this.effectiveBufferTime/o>this.computedStabilizationTimeInSeconds&&(this.reset(),t({message:\"ANALYZER_RESETED\"}))}async findPeaks({audioSampleRate:o,channelData:e,bufferSize:s,currentMinIndex:t,currentMaxIndex:i,postMessage:n}){await p(async a=>{if(this.nextIndexPeaks[a]>=i)return!1;let l=this.nextIndexPeaks[a]%s,{peaks:c,threshold:h}=b({audioSampleRate:o,data:e,threshold:a,offset:l});if(c.length===0)return!1;for(let F of c){let k=t+F;this.nextIndexPeaks[h]=k+this.options.muteTimeInIndexes,this.validPeaks[h].push(k),this.options.debug&&n({message:\"VALID_PEAK\",data:{threshold:h,index:k}})}return!1},this.minValidThreshold)}};var A=class extends AudioWorkletProcessor{constructor(e){super(e);this.stopped=!1;this.aggregate=m(),this.realTimeBpmAnalyzer=new f(e.processorOptions),this.port.addEventListener(\"message\",this.onMessage.bind(this)),this.port.start()}onMessage(e){e.data.message===\"RESET\"&&(console.log(\"[processor.onMessage] RESET\"),this.aggregate=m(),this.stopped=!1,this.realTimeBpmAnalyzer.reset()),e.data.message===\"STOP\"&&(console.log(\"[processor.onMessage] STOP\"),this.aggregate=m(),this.stopped=!0,this.realTimeBpmAnalyzer.reset())}process(e,s,t){let i=e[0][0];if(this.stopped||!i)return!0;let{isBufferFull:n,buffer:a,bufferSize:l}=this.aggregate(i);return n&&this.realTimeBpmAnalyzer.analyzeChunck({audioSampleRate:sampleRate,channelData:a,bufferSize:l,postMessage:c=>{this.port.postMessage(c)}}).catch(c=>{console.error(c)}),!0}};registerProcessor(x,A);var L={};})();\n//# sourceMappingURL=realtime-bpm-processor.js.map\n`;\n", "import * as consts from './consts';\nimport type {Peaks, ValidPeaks, NextIndexPeaks, OnThresholdFunction, AggregateData} from './types';\n\n/**\n * Loop between .9 and minValidThreshold at .2 by default, passing the threshold to the function\n * @param onThreshold Function for each iteration, you must return a boolean, true will exit the loop process\n * @param minValidThreshold minValidThreshold usualy 0.2\n * @param startThreshold startThreshold usualy 0.9\n * @param thresholdStep thresholdStep usuably 0.05\n * @returns A promise that resolves nothing\n */\nexport async function descendingOverThresholds(onThreshold: OnThresholdFunction, minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): Promise<void> {\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    const shouldExit = await onThreshold(threshold);\n    if (shouldExit) {\n      break;\n    }\n  } while (threshold > minValidThreshold);\n}\n\n/**\n * Generate an object with keys as thresholds and will containes validPeaks\n * @param minValidThreshold minValidThreshold usualy 0.2\n * @param startThreshold startThreshold usualy 0.9\n * @param thresholdStep thresholdStep usuably 0.05\n * @returns Collection of validPeaks by thresholds\n */\nexport function generateValidPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): ValidPeaks {\n  const object: Record<string, Peaks> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = [];\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\n/**\n * Generate an object with keys as thresholds and will containes NextIndexPeaks\n * @param minValidThreshold Minimum threshold to reach (we're descending from the startThreshold)\n * @param startThreshold Starting threshold\n * @param thresholdStep Usually 0.05\n * @returns Collection of NextIndexPeaks by thresholds\n */\nexport function generateNextIndexPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): NextIndexPeaks {\n  const object: Record<string, number> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = 0;\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\n/**\n * Creates a function that aggregates incoming PCM data into chunks.\n * @returns A function that accepts PCM data and aggregates it into chunks.\n */\nexport function chunckAggregator(): (pcmData: Float32Array) => AggregateData {\n  const bufferSize = 4096;\n\n  /**\n   * Track the current buffer fill level.\n   */\n  let _bytesWritten = 0;\n\n  /**\n   * Create a buffer of fixed size.\n   */\n  let buffer: Float32Array = new Float32Array(0);\n\n  /**\n   * Initialize the buffer.\n   */\n  function initBuffer(): void {\n    _bytesWritten = 0;\n    buffer = new Float32Array(0);\n  }\n\n  /**\n   * Checks if the buffer is full.\n   * @returns True if the buffer is full, otherwise false.\n   */\n  function isBufferFull(): boolean {\n    return _bytesWritten === bufferSize;\n  }\n\n  /**\n   * Flushes the buffer.\n   */\n  function flush(): void {\n    initBuffer();\n  }\n\n  /**\n   * Aggregates incoming PCM data into chunks.\n   * @param pcmData - The PCM data to be aggregated.\n   * @returns Object containing aggregated data and buffer information.\n   */\n  return function (pcmData: Float32Array): AggregateData {\n    if (isBufferFull()) {\n      flush();\n    }\n\n    const newBuffer = new Float32Array(buffer.length + pcmData.length);\n    newBuffer.set(buffer, 0);\n    newBuffer.set(pcmData, buffer.length);\n    buffer = newBuffer;\n    _bytesWritten += pcmData.length;\n\n    return {\n      isBufferFull: isBufferFull(),\n      buffer,\n      bufferSize,\n    };\n  };\n}\n\n/**\n * Computes the number of indexes we need to skip based on sampleRate\n * @param durationSeconds Duration expressed in seconds\n * @param sampleRate Sample rate, typically 48000, 441000, etc\n * @returns The number of indexes we need to skip\n */\nexport function computeIndexesToSkip(durationSeconds: number, sampleRate: number): number {\n  return Math.round(durationSeconds * sampleRate);\n}\n", "import {descendingOverThresholds} from './utils';\nimport type {\n  Peaks,\n  PeaksAndThreshold,\n  BpmCandidates,\n  Interval,\n  Tempo,\n  Threshold,\n  AnalyzerFindPeaksOptions,\n  AnalyzerGroupByTempoOptions,\n  AnalyzerComputeBpmOptions,\n  BiquadFilterOptions,\n  AnalyzerFindPeaksAtTheshold,\n} from './types';\nimport * as consts from './consts';\nimport * as utils from './utils';\n\n/**\n * Find peaks when the signal if greater than the threshold, then move 10_000 indexes (represents ~0.23s) to ignore the descending phase of the parabol\n * @param options - AnalyzerFindPeaksAtTheshold\n * @param options.audioSampleRate - Sample rate\n * @param options.data - Buffer channel data\n * @param options.threshold - Threshold for qualifying as a peak\n * @param options.offset - Position where we start to loop\n * @returns Peaks found that are greater than the threshold\n */\nexport function findPeaksAtThreshold({\n  audioSampleRate,\n  data,\n  threshold,\n  offset = 0,\n}: AnalyzerFindPeaksAtTheshold): PeaksAndThreshold {\n  const peaks: Peaks = [];\n  const skipForwardIndexes = utils.computeIndexesToSkip(0.25, audioSampleRate);\n\n  const {length} = data;\n\n  /**\n   * Identify peaks that are greater than the threshold, adding them to the collection\n   */\n  for (let i = offset; i < length; i += 1) {\n    if (data[i] > threshold) {\n      peaks.push(i);\n\n      /**\n       * Skip forward ~0.25s to pass this peak\n       */\n      i += skipForwardIndexes;\n    }\n  }\n\n  return {\n    peaks,\n    threshold,\n  };\n}\n\n/**\n * Find the minimum amount of peaks from top to bottom threshold, it's necessary to analyze at least 10seconds at 90bpm\n * @param options - AnalyzerFindPeaksOptions\n * @param options.audioSampleRate - Sample rate\n * @param options.channelData - Channel data\n * @returns Suffisent amount of peaks in order to continue further the process\n */\nexport async function findPeaks({\n  audioSampleRate,\n  channelData,\n}: AnalyzerFindPeaksOptions): Promise<PeaksAndThreshold> {\n  let validPeaks: Peaks = [];\n  let validThreshold = 0;\n\n  await descendingOverThresholds(async threshold => {\n    const {peaks} = findPeaksAtThreshold({audioSampleRate, data: channelData, threshold});\n\n    /**\n     * Loop over peaks\n     */\n    if (peaks.length < consts.minPeaks) {\n      return false;\n    }\n\n    validPeaks = peaks;\n    validThreshold = threshold;\n\n    return true;\n  });\n\n  return {\n    peaks: validPeaks,\n    threshold: validThreshold,\n  };\n}\n\n/**\n * Helpfull function to create standard and shared lowpass and highpass filters\n * Important Note: The original library wasn't using properly the lowpass filter and it was not applied at all.\n * This method should not be used unitl more research and documented tests will be acheived.\n * @param context - AudioContext instance\n * @param options - Optionnal BiquadFilterOptions\n * @returns BiquadFilterNode\n */\nexport function getBiquadFilter(context: OfflineAudioContext | AudioContext, options?: BiquadFilterOptions): BiquadFilterNode {\n  const lowpass = context.createBiquadFilter();\n\n  lowpass.type = 'lowpass';\n  lowpass.frequency.value = options?.frequencyValue ?? consts.frequencyValue;\n  lowpass.Q.value = options?.qualityValue ?? consts.qualityValue;\n\n  return lowpass;\n}\n\n/**\n * Apply to the source a biquad lowpass filter\n * @param buffer - Audio buffer\n * @param options - Optionnal BiquadFilterOptions\n * @returns A Promise that resolves an AudioBuffer instance\n */\nexport async function getOfflineLowPassSource(buffer: AudioBuffer, options?: BiquadFilterOptions): Promise<AudioBuffer> {\n  const {length, numberOfChannels, sampleRate} = buffer;\n  const offlineAudioContext = new OfflineAudioContext(numberOfChannels, length, sampleRate);\n\n  /**\n   * Create buffer source\n   */\n  const source = offlineAudioContext.createBufferSource();\n  source.buffer = buffer;\n\n  const lowpass = getBiquadFilter(offlineAudioContext, options);\n\n  /**\n   * Pipe the song into the filter, and the filter into the offline context\n   */\n  source.connect(lowpass);\n  lowpass.connect(offlineAudioContext.destination);\n\n  source.start(0);\n\n  const audioBuffer = await offlineAudioContext.startRendering();\n\n  return audioBuffer;\n}\n\n/**\n * Return the computed bpm from data\n * @param options - AnalyzerComputeBpmOptions\n * @param options.data - Contain valid peaks\n * @param options.audioSampleRate - Audio sample rate\n * @returns A Promise that resolves BPM Candidates\n */\nexport async function computeBpm({\n  audioSampleRate,\n  data,\n}: AnalyzerComputeBpmOptions): Promise<BpmCandidates> {\n  const minPeaks = consts.minPeaks;\n\n  /**\n   * Flag to fix Object.keys looping\n   */\n  let hasPeaks = false;\n  let foundThreshold = consts.minValidThreshold;\n\n  await descendingOverThresholds(async (threshold: Threshold) => {\n    if (hasPeaks) {\n      return true;\n    }\n\n    if (data[threshold].length > minPeaks) {\n      hasPeaks = true;\n      foundThreshold = threshold;\n    }\n\n    return false;\n  });\n\n  if (hasPeaks && foundThreshold) {\n    const intervals = identifyIntervals(data[foundThreshold]);\n    const tempos = groupByTempo({audioSampleRate, intervalCounts: intervals});\n    const candidates = getTopCandidates(tempos);\n\n    const bpmCandidates: BpmCandidates = {\n      bpm: candidates,\n      threshold: foundThreshold,\n    };\n\n    return bpmCandidates;\n  }\n\n  return {\n    bpm: [],\n    threshold: foundThreshold,\n  };\n}\n\n/**\n * Sort results by count and return top candidate\n * @param candidates - BPMs with count\n * @param length - Amount of returned candidates (default: 5)\n * @returns Returns the 5 top candidates with highest counts\n */\nexport function getTopCandidates(candidates: Tempo[], length = 5): Tempo[] {\n  return candidates.sort((a, b) => (b.count - a.count)).splice(0, length);\n}\n\n/**\n * Gets the top candidate from the array\n * @param candidates - BPMs with counts.\n * @returns Returns the top candidate with the highest count.\n */\nexport function getTopCandidate(candidates: Tempo[]): number {\n  if (candidates.length === 0) {\n    throw new Error('Could not find enough samples for a reliable detection.');\n  }\n\n  const [first] = candidates.sort((a, b) => (b.count - a.count));\n\n  return first.tempo;\n}\n\n/**\n * Identify intervals between bass peaks\n * @param peaks - Array of qualified bass peaks\n * @returns Return a collection of intervals between peaks\n */\nexport function identifyIntervals(peaks: Peaks): Interval[] {\n  const intervals: Interval[] = [];\n\n  for (let n = 0; n < peaks.length; n++) {\n    for (let i = 0; i < 10; i++) {\n      const peak = peaks[n];\n      const peakIndex = n + i;\n      const interval = peaks[peakIndex] - peak;\n\n      /**\n       * Try and find a matching interval and increase it's count\n       */\n      const foundInterval = intervals.some((intervalCount: Interval) => {\n        if (intervalCount.interval === interval) {\n          intervalCount.count += 1;\n          return intervalCount.count;\n        }\n\n        return false;\n      });\n\n      /**\n       * Add the interval to the collection if it's unique\n       */\n      if (!foundInterval) {\n        const item: Interval = {\n          interval,\n          count: 1,\n        };\n        intervals.push(item);\n      }\n    }\n  }\n\n  return intervals;\n}\n\n/**\n * Figure out best possible tempo candidates\n * @param options - AnalyzerGroupByTempoOptions\n * @param options.audioSampleRate - Audio sample rate\n * @param options.intervalCounts - List of identified intervals\n * @returns Intervals grouped with similar values\n */\nexport function groupByTempo({\n  audioSampleRate,\n  intervalCounts,\n}: AnalyzerGroupByTempoOptions): Tempo[] {\n  const tempoCounts: Tempo[] = [];\n\n  for (const intervalCount of intervalCounts) {\n    /**\n     * Skip if interval is equal 0\n     */\n    if (intervalCount.interval === 0) {\n      continue;\n    }\n\n    intervalCount.interval = Math.abs(intervalCount.interval);\n\n    /**\n     * Convert an interval to tempo\n     */\n    let theoreticalTempo = (60 / (intervalCount.interval / audioSampleRate));\n\n    /**\n     * Adjust the tempo to fit within the 90-180 BPM range\n     */\n    while (theoreticalTempo < 90) {\n      theoreticalTempo *= 2;\n    }\n\n    while (theoreticalTempo > 180) {\n      theoreticalTempo /= 2;\n    }\n\n    /**\n     * Round to legible integer\n     */\n    theoreticalTempo = Math.round(theoreticalTempo);\n\n    /**\n     * See if another interval resolved to the same tempo\n     */\n    const foundTempo: boolean = tempoCounts.some((tempoCount: Tempo) => {\n      if (tempoCount.tempo === theoreticalTempo) {\n        tempoCount.count += intervalCount.count;\n        return tempoCount.count;\n      }\n\n      return false;\n    });\n\n    /**\n     * Add a unique tempo to the collection\n     */\n    if (!foundTempo) {\n      const tempo: Tempo = {\n        tempo: theoreticalTempo,\n        count: intervalCount.count,\n        confidence: 0,\n      };\n\n      tempoCounts.push(tempo);\n    }\n  }\n\n  return tempoCounts;\n}\n\n/**\n * Fastest way to detect the BPM from an AudioBuffer\n * @param originalBuffer - AudioBuffer\n * @param options - BiquadFilterOptions\n * @returns Returns the best candidates\n */\nexport async function analyzeFullBuffer(originalBuffer: AudioBuffer, options?: BiquadFilterOptions): Promise<Tempo[]> {\n  const buffer = await getOfflineLowPassSource(originalBuffer, options);\n  const channelData = buffer.getChannelData(0);\n  const {peaks} = await findPeaks({audioSampleRate: buffer.sampleRate, channelData});\n  const intervals = identifyIntervals(peaks);\n  const tempos = groupByTempo({audioSampleRate: buffer.sampleRate, intervalCounts: intervals});\n  const topCandidates = getTopCandidates(tempos);\n\n  return topCandidates;\n}\n", "import {findPeaksAtThreshold, computeBpm} from './analyzer';\nimport type {\n  RealTimeBpmAnalyzerOptions,\n  RealTimeBpmAnalyzerParameters,\n  ValidPeaks,\n  NextIndexPeaks,\n  BpmCandidates,\n  Threshold,\n  RealtimeFindPeaksOptions,\n  RealtimeAnalyzeChunkOptions,\n} from './types';\nimport {\n  generateValidPeaksModel,\n  generateNextIndexPeaksModel,\n  descendingOverThresholds,\n} from './utils';\nimport * as consts from './consts';\n\n/**\n * Initial value of key parameters of the analyzer\n */\nconst initialValue = {\n  minValidThreshold: () => consts.minValidThreshold,\n  validPeaks: () => generateValidPeaksModel(),\n  nextIndexPeaks: () => generateNextIndexPeaksModel(),\n  skipIndexes: () => 1,\n  effectiveBufferTime: () => 0,\n};\n\nexport class RealTimeBpmAnalyzer {\n  /**\n   * Default configuration\n   */\n  options: RealTimeBpmAnalyzerOptions = {\n    continuousAnalysis: false,\n    stabilizationTime: 20000,\n    muteTimeInIndexes: 10000,\n    debug: false,\n  };\n\n  /**\n   * Minimum valid threshold, below this level result would be irrelevant.\n   */\n  minValidThreshold: Threshold = initialValue.minValidThreshold();\n  /**\n   * Contain all valid peaks\n   */\n  validPeaks: ValidPeaks = initialValue.validPeaks();\n  /**\n   * Next index (+10000 ...) to take care about peaks\n   */\n  nextIndexPeaks: NextIndexPeaks = initialValue.nextIndexPeaks();\n  /**\n   * Number / Position of chunks\n   */\n  skipIndexes: number = initialValue.skipIndexes();\n  effectiveBufferTime: number = initialValue.effectiveBufferTime();\n  /**\n   * Computed values\n   */\n  computedStabilizationTimeInSeconds = 0;\n\n  constructor(options: RealTimeBpmAnalyzerParameters = {}) {\n    Object.assign(this.options, options);\n    this.updateComputedValues();\n  }\n\n  /**\n   * Update the computed values\n   */\n  updateComputedValues() {\n    this.computedStabilizationTimeInSeconds = this.options.stabilizationTime / 1000;\n  }\n\n  /**\n   * Reset BPM computation properties to get a fresh start\n   */\n  reset(): void {\n    this.minValidThreshold = initialValue.minValidThreshold();\n    this.validPeaks = initialValue.validPeaks();\n    this.nextIndexPeaks = initialValue.nextIndexPeaks();\n    this.skipIndexes = initialValue.skipIndexes();\n    this.effectiveBufferTime = initialValue.effectiveBufferTime();\n  }\n\n  /**\n   * Remve all validPeaks between the minThreshold pass in param to optimize the weight of datas\n   * @param minThreshold - Value between 0.9 and 0.2\n   */\n  async clearValidPeaks(minThreshold: Threshold): Promise<void> {\n    this.minValidThreshold = Number.parseFloat(minThreshold.toFixed(2));\n\n    await descendingOverThresholds(async threshold => {\n      if (threshold < minThreshold && this.validPeaks[threshold] !== undefined) {\n        delete this.validPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n        delete this.nextIndexPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * Attach this function to an audioprocess event on a audio/video node to compute BPM / Tempo in realtime\n   * @param options - RealtimeAnalyzeChunkOptions\n   * @param options.audioSampleRate - Audio sample rate (44100)\n   * @param options.channelData - Channel data\n   * @param options.bufferSize - Buffer size (4096)\n   * @param options.postMessage - Function to post a message to the processor node\n   */\n  async analyzeChunck({audioSampleRate, channelData, bufferSize, postMessage}: RealtimeAnalyzeChunkOptions): Promise<void> {\n    if (this.options.debug) {\n      postMessage({message: 'ANALYZE_CHUNK', data: channelData});\n    }\n\n    /**\n     * We are summing up the size of each analyzed chunks in order to compute later if we reached the stabilizationTime\n     * Ex: effectiveBufferTime / audioSampleRate = timeInSeconds (1000000/44100=22s)\n     */\n    this.effectiveBufferTime += bufferSize;\n\n    /**\n     * Compute the maximum index with all previous chunks\n     */\n    const currentMaxIndex = bufferSize * this.skipIndexes;\n\n    /**\n     * Compute the minimum index with all previous chunks\n     */\n    const currentMinIndex = currentMaxIndex - bufferSize;\n\n    /**\n     * Mutate nextIndexPeaks and validPeaks if possible\n     */\n    await this.findPeaks({\n      audioSampleRate,\n      channelData,\n      bufferSize,\n      currentMinIndex,\n      currentMaxIndex,\n      postMessage,\n    });\n\n    /**\n     * Increment chunk\n     */\n    this.skipIndexes++;\n\n    const data: BpmCandidates = await computeBpm({audioSampleRate, data: this.validPeaks});\n    const {threshold} = data;\n    postMessage({message: 'BPM', data});\n\n    /**\n     * If the results found have a \"high\" threshold, the BPM is considered stable/strong\n     */\n    if (this.minValidThreshold < threshold) {\n      postMessage({message: 'BPM_STABLE', data});\n      await this.clearValidPeaks(threshold);\n    }\n\n    /**\n     * After x time, we reinit the analyzer\n     */\n    if (this.options.continuousAnalysis && this.effectiveBufferTime / audioSampleRate > this.computedStabilizationTimeInSeconds) {\n      this.reset();\n      postMessage({message: 'ANALYZER_RESETED'});\n    }\n  }\n\n  /**\n   * Find the best threshold with enought peaks\n   * @param options - Options for finding peaks\n   * @param options.audioSampleRate - Sample rate\n   * @param options.channelData - Channel data\n   * @param options.bufferSize - Buffer size\n   * @param options.currentMinIndex - Current minimum index\n   * @param options.currentMaxIndex - Current maximum index\n   * @param options.postMessage - Function to post a message to the processor node\n   */\n  async findPeaks({\n    audioSampleRate,\n    channelData,\n    bufferSize,\n    currentMinIndex,\n    currentMaxIndex,\n    postMessage,\n  }: RealtimeFindPeaksOptions): Promise<void> {\n    await descendingOverThresholds(async threshold => {\n      if (this.nextIndexPeaks[threshold] >= currentMaxIndex) {\n        return false;\n      }\n\n      /**\n       * Get the next index in the next chunk\n       */\n      const offsetForNextPeak = this.nextIndexPeaks[threshold] % bufferSize; // 0 - 4095\n\n      const {peaks, threshold: atThreshold} = findPeaksAtThreshold({audioSampleRate, data: channelData, threshold, offset: offsetForNextPeak});\n\n      /**\n       * Loop over peaks\n       */\n      if (peaks.length === 0) {\n        return false;\n      }\n\n      for (const relativeChunkPeak of peaks) {\n        const index = currentMinIndex + relativeChunkPeak;\n\n        /**\n         * Add current Index + muteTimeInIndexes (10000/44100=0.22s)\n         */\n        this.nextIndexPeaks[atThreshold] = index + this.options.muteTimeInIndexes;\n\n        /**\n         * Store valid relativeChunkPeak Indexes\n         */\n        this.validPeaks[atThreshold].push(index);\n\n        if (this.options.debug) {\n          postMessage({\n            message: 'VALID_PEAK',\n            data: {\n              threshold: atThreshold,\n              index,\n            },\n          });\n        }\n      }\n\n      return false;\n    }, this.minValidThreshold);\n  }\n}\n", "import {realtimeBpmProcessorName} from './consts';\nimport realtimeBpmProcessorContent from './generated-processor';\nimport {type RealTimeBpmAnalyzerParameters} from './types';\n\nexport * from './realtime-bpm-analyzer';\nexport {analyzeFullBuffer, getBiquadFilter} from './analyzer';\nexport * from './types';\n\n/**\n * Create the RealTimeBpmProcessor needed to run the realtime strategy\n * @param audioContext AudioContext instance\n * @param processorOptions RealTimeBpmAnalyzerParameters\n * @returns An AudioWorkletNode instance\n */\nexport async function createRealTimeBpmProcessor(audioContext: AudioContext, processorOptions?: RealTimeBpmAnalyzerParameters): Promise<AudioWorkletNode> {\n  const processorNode = await setupAudioWorkletNode(audioContext, realtimeBpmProcessorName, processorOptions);\n\n  await audioContext.resume();\n\n  return processorNode;\n}\n\n/**\n * Creates AudioWorkletNode for the Processor\n * @param audioContext AudioContext instance\n * @param processorName Name of the audio processor, without the extension\n * @param processorOptions RealTimeBpmAnalyzerParameters\n * @returns Recording node related components for the app.\n */\nasync function setupAudioWorkletNode(audioContext: AudioContext, processorName: string, processorOptions?: RealTimeBpmAnalyzerParameters): Promise<AudioWorkletNode> {\n  const blob = new Blob([realtimeBpmProcessorContent], {type: 'application/javascript'});\n\n  const objectUrl = URL.createObjectURL(blob);\n\n  await audioContext.audioWorklet.addModule(objectUrl);\n\n  const audioWorkletNode = new AudioWorkletNode(audioContext, processorName, {\n    processorOptions,\n  });\n\n  return audioWorkletNode;\n}\n"],
  "mappings": "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",
  "names": ["realtimeBpmProcessorName", "generated_processor_default", "descendingOverThresholds", "onThreshold", "minValidThreshold", "startThreshold", "thresholdStep", "threshold", "generateValidPeaksModel", "object", "generateNextIndexPeaksModel", "computeIndexesToSkip", "durationSeconds", "sampleRate", "findPeaksAtThreshold", "audioSampleRate", "data", "offset", "peaks", "skipForwardIndexes", "length", "i", "findPeaks", "channelData", "validPeaks", "validThreshold", "getBiquadFilter", "context", "options", "lowpass", "getOfflineLowPassSource", "buffer", "numberOfChannels", "offlineAudioContext", "source", "computeBpm", "minPeaks", "hasPeaks", "foundThreshold", "intervals", "identifyIntervals", "tempos", "groupByTempo", "getTopCandidates", "candidates", "a", "b", "n", "peak", "peakIndex", "interval", "intervalCount", "item", "intervalCounts", "tempoCounts", "theoreticalTempo", "tempoCount", "tempo", "analyzeFullBuffer", "originalBuffer", "initialValue", "RealTimeBpmAnalyzer", "minThreshold", "bufferSize", "postMessage", "currentMaxIndex", "currentMinIndex", "offsetForNextPeak", "atThreshold", "relativeChunkPeak", "index", "createRealTimeBpmProcessor", "audioContext", "processorOptions", "processorNode", "setupAudioWorkletNode", "processorName", "blob", "objectUrl"]
}
