import "./chunk-5WWUZCGV.js";

// node_modules/realtime-bpm-analyzer/dist/index.esm.js
var T = "realtime-bpm-processor";
var g = `"use strict";(()=>{var x="realtime-bpm-processor";async function p(r,o=.2,e=.95,s=.05){let t=e;do if(t-=s,await r(t))break;while(t>o)}function y(r=.2,o=.95,e=.05){let s={},t=o;do t-=e,s[t.toString()]=[];while(t>r);return s}function v(r=.2,o=.95,e=.05){let s={},t=o;do t-=e,s[t.toString()]=0;while(t>r);return s}function m(){let o=0,e=new Float32Array(0);function s(){o=0,e=new Float32Array(0)}function t(){return o===4096}function i(){s()}return function(n){t()&&i();let a=new Float32Array(e.length+n.length);return a.set(e,0),a.set(n,e.length),e=a,o+=n.length,{isBufferFull:t(),buffer:e,bufferSize:4096}}}function B(r,o){return Math.round(r*o)}function b({audioSampleRate:r,data:o,threshold:e,offset:s=0}){let t=[],i=B(.25,r),{length:n}=o;for(let a=s;a<n;a+=1)o[a]>e&&(t.push(a),a+=i);return{peaks:t,threshold:e}}async function I({audioSampleRate:r,data:o}){let e=15,s=!1,t=.2;if(await p(async i=>s?!0:(o[i].length>e&&(s=!0,t=i),!1)),s&&t){let i=O(o[t]),n=S({audioSampleRate:r,intervalCounts:i});return{bpm:C(n),threshold:t}}return{bpm:[],threshold:t}}function C(r,o=5){return r.sort((e,s)=>s.count-e.count).splice(0,o)}function O(r){let o=[];for(let e=0;e<r.length;e++)for(let s=0;s<10;s++){let t=r[e],i=e+s,n=r[i]-t;if(!o.some(l=>l.interval===n?(l.count+=1,l.count):!1)){let l={interval:n,count:1};o.push(l)}}return o}function S({audioSampleRate:r,intervalCounts:o}){let e=[];for(let s of o){if(s.interval===0)continue;s.interval=Math.abs(s.interval);let t=60/(s.interval/r);for(;t<90;)t*=2;for(;t>180;)t/=2;if(t=Math.round(t),!e.some(n=>n.tempo===t?(n.count+=s.count,n.count):!1)){let n={tempo:t,count:s.count,confidence:0};e.push(n)}}return e}var d={minValidThreshold:()=>.2,validPeaks:()=>y(),nextIndexPeaks:()=>v(),skipIndexes:()=>1,effectiveBufferTime:()=>0},f=class{constructor(o={}){this.options={continuousAnalysis:!1,stabilizationTime:2e4,muteTimeInIndexes:1e4,debug:!1};this.minValidThreshold=d.minValidThreshold();this.validPeaks=d.validPeaks();this.nextIndexPeaks=d.nextIndexPeaks();this.skipIndexes=d.skipIndexes();this.effectiveBufferTime=d.effectiveBufferTime();this.computedStabilizationTimeInSeconds=0;Object.assign(this.options,o),this.updateComputedValues()}updateComputedValues(){this.computedStabilizationTimeInSeconds=this.options.stabilizationTime/1e3}reset(){this.minValidThreshold=d.minValidThreshold(),this.validPeaks=d.validPeaks(),this.nextIndexPeaks=d.nextIndexPeaks(),this.skipIndexes=d.skipIndexes(),this.effectiveBufferTime=d.effectiveBufferTime()}async clearValidPeaks(o){this.minValidThreshold=Number.parseFloat(o.toFixed(2)),await p(async e=>(e<o&&this.validPeaks[e]!==void 0&&(delete this.validPeaks[e],delete this.nextIndexPeaks[e]),!1))}async analyzeChunck({audioSampleRate:o,channelData:e,bufferSize:s,postMessage:t}){this.options.debug&&t({message:"ANALYZE_CHUNK",data:e}),this.effectiveBufferTime+=s;let i=s*this.skipIndexes,n=i-s;await this.findPeaks({audioSampleRate:o,channelData:e,bufferSize:s,currentMinIndex:n,currentMaxIndex:i,postMessage:t}),this.skipIndexes++;let a=await I({audioSampleRate:o,data:this.validPeaks}),{threshold:l}=a;t({message:"BPM",data:a}),this.minValidThreshold<l&&(t({message:"BPM_STABLE",data:a}),await this.clearValidPeaks(l)),this.options.continuousAnalysis&&this.effectiveBufferTime/o>this.computedStabilizationTimeInSeconds&&(this.reset(),t({message:"ANALYZER_RESETED"}))}async findPeaks({audioSampleRate:o,channelData:e,bufferSize:s,currentMinIndex:t,currentMaxIndex:i,postMessage:n}){await p(async a=>{if(this.nextIndexPeaks[a]>=i)return!1;let l=this.nextIndexPeaks[a]%s,{peaks:c,threshold:h}=b({audioSampleRate:o,data:e,threshold:a,offset:l});if(c.length===0)return!1;for(let F of c){let k=t+F;this.nextIndexPeaks[h]=k+this.options.muteTimeInIndexes,this.validPeaks[h].push(k),this.options.debug&&n({message:"VALID_PEAK",data:{threshold:h,index:k}})}return!1},this.minValidThreshold)}};var A=class extends AudioWorkletProcessor{constructor(e){super(e);this.stopped=!1;this.aggregate=m(),this.realTimeBpmAnalyzer=new f(e.processorOptions),this.port.addEventListener("message",this.onMessage.bind(this)),this.port.start()}onMessage(e){e.data.message==="RESET"&&(console.log("[processor.onMessage] RESET"),this.aggregate=m(),this.stopped=!1,this.realTimeBpmAnalyzer.reset()),e.data.message==="STOP"&&(console.log("[processor.onMessage] STOP"),this.aggregate=m(),this.stopped=!0,this.realTimeBpmAnalyzer.reset())}process(e,s,t){let i=e[0][0];if(this.stopped||!i)return!0;let{isBufferFull:n,buffer:a,bufferSize:l}=this.aggregate(i);return n&&this.realTimeBpmAnalyzer.analyzeChunck({audioSampleRate:sampleRate,channelData:a,bufferSize:l,postMessage:c=>{this.port.postMessage(c)}}).catch(c=>{console.error(c)}),!0}};registerProcessor(x,A);var L={};})();
//# sourceMappingURL=realtime-bpm-processor.js.map
`;
async function c(o, s = 0.2, e = 0.95, n = 0.05) {
  let t = e;
  do
    if (t -= n, await o(t))
      break;
  while (t > s);
}
function y(o = 0.2, s = 0.95, e = 0.05) {
  let n = {}, t = s;
  do
    t -= e, n[t.toString()] = [];
  while (t > o);
  return n;
}
function v(o = 0.2, s = 0.95, e = 0.05) {
  let n = {}, t = s;
  do
    t -= e, n[t.toString()] = 0;
  while (t > o);
  return n;
}
function A(o, s) {
  return Math.round(o * s);
}
function x({ audioSampleRate: o, data: s, threshold: e, offset: n = 0 }) {
  let t = [], i = A(0.25, o), { length: a } = s;
  for (let r = n; r < a; r += 1)
    s[r] > e && (t.push(r), r += i);
  return { peaks: t, threshold: e };
}
async function M({ audioSampleRate: o, channelData: s }) {
  let e = [], n = 0;
  return await c(async (t) => {
    let { peaks: i } = x({ audioSampleRate: o, data: s, threshold: t });
    return i.length < 15 ? false : (e = i, n = t, true);
  }), { peaks: e, threshold: n };
}
function B(o, s) {
  let e = o.createBiquadFilter();
  return e.type = "lowpass", e.frequency.value = (s == null ? void 0 : s.frequencyValue) ?? 200, e.Q.value = (s == null ? void 0 : s.qualityValue) ?? 1, e;
}
async function N(o, s) {
  let { length: e, numberOfChannels: n, sampleRate: t } = o, i = new OfflineAudioContext(n, e, t), a = i.createBufferSource();
  a.buffer = o;
  let r = B(i, s);
  return a.connect(r), r.connect(i.destination), a.start(0), await i.startRendering();
}
async function b({ audioSampleRate: o, data: s }) {
  let e = 15, n = false, t = 0.2;
  if (await c(async (i) => n ? true : (s[i].length > e && (n = true, t = i), false)), n && t) {
    let i = w(s[t]), a = V({ audioSampleRate: o, intervalCounts: i });
    return { bpm: S(a), threshold: t };
  }
  return { bpm: [], threshold: t };
}
function S(o, s = 5) {
  return o.sort((e, n) => n.count - e.count).splice(0, s);
}
function w(o) {
  let s = [];
  for (let e = 0; e < o.length; e++)
    for (let n = 0; n < 10; n++) {
      let t = o[e], i = e + n, a = o[i] - t;
      if (!s.some((l) => l.interval === a ? (l.count += 1, l.count) : false)) {
        let l = { interval: a, count: 1 };
        s.push(l);
      }
    }
  return s;
}
function V({ audioSampleRate: o, intervalCounts: s }) {
  let e = [];
  for (let n of s) {
    if (n.interval === 0)
      continue;
    n.interval = Math.abs(n.interval);
    let t = 60 / (n.interval / o);
    for (; t < 90; )
      t *= 2;
    for (; t > 180; )
      t /= 2;
    if (t = Math.round(t), !e.some((a) => a.tempo === t ? (a.count += n.count, a.count) : false)) {
      let a = { tempo: t, count: n.count, confidence: 0 };
      e.push(a);
    }
  }
  return e;
}
async function E(o, s) {
  let e = await N(o, s), n = e.getChannelData(0), { peaks: t } = await M({ audioSampleRate: e.sampleRate, channelData: n }), i = w(t), a = V({ audioSampleRate: e.sampleRate, intervalCounts: i });
  return S(a);
}
var d = { minValidThreshold: () => 0.2, validPeaks: () => y(), nextIndexPeaks: () => v(), skipIndexes: () => 1, effectiveBufferTime: () => 0 };
var z = class {
  constructor(s = {}) {
    this.options = { continuousAnalysis: false, stabilizationTime: 2e4, muteTimeInIndexes: 1e4, debug: false };
    this.minValidThreshold = d.minValidThreshold();
    this.validPeaks = d.validPeaks();
    this.nextIndexPeaks = d.nextIndexPeaks();
    this.skipIndexes = d.skipIndexes();
    this.effectiveBufferTime = d.effectiveBufferTime();
    this.computedStabilizationTimeInSeconds = 0;
    Object.assign(this.options, s), this.updateComputedValues();
  }
  updateComputedValues() {
    this.computedStabilizationTimeInSeconds = this.options.stabilizationTime / 1e3;
  }
  reset() {
    this.minValidThreshold = d.minValidThreshold(), this.validPeaks = d.validPeaks(), this.nextIndexPeaks = d.nextIndexPeaks(), this.skipIndexes = d.skipIndexes(), this.effectiveBufferTime = d.effectiveBufferTime();
  }
  async clearValidPeaks(s) {
    this.minValidThreshold = Number.parseFloat(s.toFixed(2)), await c(async (e) => (e < s && this.validPeaks[e] !== void 0 && (delete this.validPeaks[e], delete this.nextIndexPeaks[e]), false));
  }
  async analyzeChunck({ audioSampleRate: s, channelData: e, bufferSize: n, postMessage: t }) {
    this.options.debug && t({ message: "ANALYZE_CHUNK", data: e }), this.effectiveBufferTime += n;
    let i = n * this.skipIndexes, a = i - n;
    await this.findPeaks({ audioSampleRate: s, channelData: e, bufferSize: n, currentMinIndex: a, currentMaxIndex: i, postMessage: t }), this.skipIndexes++;
    let r = await b({ audioSampleRate: s, data: this.validPeaks }), { threshold: l } = r;
    t({ message: "BPM", data: r }), this.minValidThreshold < l && (t({ message: "BPM_STABLE", data: r }), await this.clearValidPeaks(l)), this.options.continuousAnalysis && this.effectiveBufferTime / s > this.computedStabilizationTimeInSeconds && (this.reset(), t({ message: "ANALYZER_RESETED" }));
  }
  async findPeaks({ audioSampleRate: s, channelData: e, bufferSize: n, currentMinIndex: t, currentMaxIndex: i, postMessage: a }) {
    await c(async (r) => {
      if (this.nextIndexPeaks[r] >= i)
        return false;
      let l = this.nextIndexPeaks[r] % n, { peaks: P, threshold: h } = x({ audioSampleRate: s, data: e, threshold: r, offset: l });
      if (P.length === 0)
        return false;
      for (let F of P) {
        let f = t + F;
        this.nextIndexPeaks[h] = f + this.options.muteTimeInIndexes, this.validPeaks[h].push(f), this.options.debug && a({ message: "VALID_PEAK", data: { threshold: h, index: f } });
      }
      return false;
    }, this.minValidThreshold);
  }
};
async function Z(o, s) {
  let e = await q(o, T, s);
  return await o.resume(), e;
}
async function q(o, s, e) {
  let n = new Blob([g], { type: "application/javascript" }), t = URL.createObjectURL(n);
  return await o.audioWorklet.addModule(t), new AudioWorkletNode(o, s, { processorOptions: e });
}
export {
  z as RealTimeBpmAnalyzer,
  E as analyzeFullBuffer,
  Z as createRealTimeBpmProcessor,
  B as getBiquadFilter
};
//# sourceMappingURL=realtime-bpm-analyzer.js.map
